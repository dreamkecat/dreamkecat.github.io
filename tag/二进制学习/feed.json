{
    "version": "https://jsonfeed.org/version/1",
    "title": "我他喵的 • All posts by \"二进制学习\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/06/27/%E5%AD%A6%E4%B9%A0%E5%91%A8%E8%AE%B0-%E2%80%94%E2%80%94%E4%B8%80/",
            "url": "http://example.com/2022/06/27/%E5%AD%A6%E4%B9%A0%E5%91%A8%E8%AE%B0-%E2%80%94%E2%80%94%E4%B8%80/",
            "title": "学习周记 ——一",
            "date_published": "2022-06-27T13:06:06.000Z",
            "content_html": "<h1 id=\"task\"><a class=\"markdownIt-Anchor\" href=\"#task\">#</a> TASK:</h1>\n<p>​\t\t编写 IDA 脚本，不依赖版本号的条件下，利用二进制特征，在 openssl 的 libssl.so 中检查 CVE-2015-0207 和 CVE-2014-3507 是否被修补</p>\n<p>要求：idc 和 python 两个版本都写一下，这个就是把 libssl.so 拖进 ida，然后运行你的脚本，然后弹窗或者输出有没有那两个 cve 存在</p>\n<p>参考链接：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuaGV4LXJheXMuY29tL3Byb2R1Y3RzL2lkYS9zdXBwb3J0L2lkYWRvYy8xNjIuc2h0bWw=\">https://www.hex-rays.com/products/ida/support/idadoc/162.shtml</span>\t\t\t\t按字母顺序排列的 IDC 函数列表</p>\n<p>不依赖版本号，就是使用 ida 通用的函数，</p>\n<h2 id=\"前置diff-dapatch\"><a class=\"markdownIt-Anchor\" href=\"#前置diff-dapatch\">#</a> 前置：diff dapatch</h2>\n<h2 id=\"对于数据的定义\"><a class=\"markdownIt-Anchor\" href=\"#对于数据的定义\">#</a> 对于数据的定义</h2>\n<p>ida 各版本通用的是划分为，整数 long，字符串 string，以及浮点数，而不做具体的划分。或者使用无定形的关键字 auto，定义一个变量。但是在模块中，我们还是要局部变量先声明。可以在任何地方都可以定义定义一个全局变量，关键字为 extern，但是不能在声明的同时，进行赋值。</p>\n<h2 id=\"运算\"><a class=\"markdownIt-Anchor\" href=\"#运算\">#</a> 运算</h2>\n<p>idc 不支持复合赋值运算，比如 i+=2 这样，但是支持三元运算符（？：）。</p>\n<h2 id=\"数据处理\"><a class=\"markdownIt-Anchor\" href=\"#数据处理\">#</a> 数据处理：</h2>\n<p>idc 这种脚本程序，最重要的就是数据的获取以及处理，idc 库提供了相关的数据获取与处理的函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">读取内存数据</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">Byte</span><span class=\"params\">(<span class=\"type\">long</span> addr)</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">Word</span><span class=\"params\">(<span class=\"type\">long</span> addr)</span>;</span><br><span class=\"line\"><span class=\"type\">long</span> <span class=\"title function_\">Dword</span><span class=\"params\">(<span class=\"type\">long</span> addr)</span>;</span><br><span class=\"line\">修改内存数据</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Patchbyte</span><span class=\"params\">(<span class=\"type\">long</span> addr)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">Patchword</span><span class=\"params\">(<span class=\"type\">long</span> addr)</span>:</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PatchDword</span><span class=\"params\">(longword)</span>;</span><br><span class=\"line\"><span class=\"comment\">//修改数据的时候，如果提供的数据长度不匹配，从低地址开始有效</span></span><br><span class=\"line\"><span class=\"type\">bool</span> <span class=\"title function_\">isLoaded</span><span class=\"params\">(<span class=\"type\">long</span> addr)</span>;\t<span class=\"comment\">//地址是否包含有效数据</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"用户交互输入输出\"><a class=\"markdownIt-Anchor\" href=\"#用户交互输入输出\">#</a> 用户交互 —— 输入输出</h2>\n<p><img data-src=\"E:%5CmyBLOG%5Cblog%5Csource_posts%5C%E5%AD%A6%E4%B9%A0%E5%91%A8%E8%AE%B0-%E2%80%94%E2%80%94%E4%B8%80%5Cimage-20220629233503199.png\" alt=\"image-20220629233503199\"></p>\n<p>所以物品们尽量使用 Message 函数进行输出 ma ?</p>\n<h2 id=\"处理函数\"><a class=\"markdownIt-Anchor\" href=\"#处理函数\">#</a> 处理函数</h2>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//获取目标地址 *所在* 函数的名字</span><br><span class=\"line\">string\tGetFunctionName(long addr);\t//如果addr不属于一个函数，则返回一个空字符串</span><br><span class=\"line\">long\tNextFunction(long addr);\t//返回addr的下一函数的起始地址，失败返回-1</span><br><span class=\"line\">long\tPrevFunction(long addr);\t//返回addr的之前距离最近的函数的起始地址，失败返回-1</span><br><span class=\"line\">long\tLocByName(string name);\t//根据名字查找函数的起始地址</span><br><span class=\"line\"></span><br><span class=\"line\">//宏定义，非法地址   BADADDR</span><br><span class=\"line\">//交叉引用</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"task1cve-2015-0207\"><a class=\"markdownIt-Anchor\" href=\"#task1cve-2015-0207\">#</a> task1:CVE-2015-0207</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- a/ssl/d1_lib.c</span><br><span class=\"line\">+++ b/ssl/d1_lib.c</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">dtls1_listen</span><span class=\"params\">(SSL *s, <span class=\"keyword\">struct</span> sockaddr *client)</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"type\">int</span> ret;</span><br><span class=\"line\"> </span><br><span class=\"line\">+    <span class=\"comment\">/* Ensure there is no state left over from a previous invocation */</span></span><br><span class=\"line\">+    SSL_clear(s);</span><br><span class=\"line\">+</span><br><span class=\"line\">     SSL_set_options(s, SSL_OP_COOKIE_EXCHANGE);</span><br><span class=\"line\">     s-&gt;d1-&gt;listen = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>检测是否修复漏洞，就是看看 dtls1_listen 函数是否调用了 SSL_clear 函数。</p>\n<p>定位到 dtls1_listen 函数的位置，遍历他的每一条指令，筛选出函数调用指令的交叉引用，所以我们需要便利的同时进行排除选择，检查交叉引用的返回值，筛选出 fl_CN 或者 fl_CF 类型的交叉引用。然后判断，调用函数的名称是否为 SSL_clear.</p>\n<p>idc 脚本</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;idc.idc&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">auto</span> func,end,target,inst,name,flags,xref;</span><br><span class=\"line\">    flags = SEARCH_DOWN | SEARCH_NEXT;</span><br><span class=\"line\">    Message(<span class=\"string\">&quot;now ,let&#x27;s begin!\\n\\n\\n*********************\\n&quot;</span>);</span><br><span class=\"line\">    func = LocByName(<span class=\"string\">&quot;dtls1_listen&quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(func == BADADDR)&#123;</span><br><span class=\"line\">\tWarning(<span class=\"string\">&quot;Sorry we cannnot find dtls1_listen in the database!&quot;</span>);</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        end = GetFunctionAttr(func,FUNCATTR_END);</span><br><span class=\"line\">        name = Name(func)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(inst = func; inst &lt;end;inst = FindCode(inst,flags))&#123;</span><br><span class=\"line\">           <span class=\"keyword\">for</span> (target = Rfirst(inst);target != BADADDR;target = Rnext(inst,target))&#123;</span><br><span class=\"line\">\t\t\t  xref = XrefType();</span><br><span class=\"line\">               <span class=\"keyword\">if</span>(xref == fl_CN || xref == fl_CF)&#123;</span><br><span class=\"line\">                   Message(<span class=\"string\">&quot;%s calls %s from 0x%x\\n&quot;</span>,name ,Name(target),inst);</span><br><span class=\"line\">                   <span class=\"keyword\">if</span>(target == LocByName(<span class=\"string\">&quot;SSL_clear&quot;</span>))&#123;</span><br><span class=\"line\">                       Message(<span class=\"string\">&quot;this database hax beens patched!&quot;</span>);</span><br><span class=\"line\">                       <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">               </span><br><span class=\"line\">           &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"task2cve-2014-3507\"><a class=\"markdownIt-Anchor\" href=\"#task2cve-2014-3507\">#</a> task2:CVE-2014-3507</h2>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--- a/ssl/d1_both.c</span><br><span class=\"line\">+++ b/ssl/d1_both.c</span><br><span class=\"line\">@@ <span class=\"number\">-616</span>,<span class=\"number\">6</span> +<span class=\"number\">616</span>,<span class=\"number\">9</span> @@ dtls1_reassemble_fragment(SSL *s, <span class=\"keyword\">struct</span> hm_header_st* msg_hdr, <span class=\"type\">int</span> *ok)</span><br><span class=\"line\">            msg_hdr-&gt;msg_len &gt; dtls1_max_handshake_message_len(s))</span><br><span class=\"line\">                <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\"> </span><br><span class=\"line\">+       <span class=\"keyword\">if</span> (frag_len == <span class=\"number\">0</span>)</span><br><span class=\"line\">+               <span class=\"keyword\">return</span> DTLS1_HM_FRAGMENT_RETRY;</span><br><span class=\"line\">+</span><br><span class=\"line\">        <span class=\"comment\">/* Try to find item in queue */</span></span><br><span class=\"line\">        <span class=\"built_in\">memset</span>(seq64be,<span class=\"number\">0</span>,<span class=\"keyword\">sizeof</span>(seq64be));</span><br><span class=\"line\">        seq64be[<span class=\"number\">6</span>] = (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>) (msg_hdr-&gt;seq&gt;&gt;<span class=\"number\">8</span>);</span><br><span class=\"line\">@@ <span class=\"number\">-693</span>,<span class=\"number\">7</span> +<span class=\"number\">696</span>,<span class=\"number\">12</span> @@ dtls1_reassemble_fragment(SSL *s, <span class=\"keyword\">struct</span> hm_header_st* msg_hdr, <span class=\"type\">int</span> *ok)</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\">                        &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">-               pqueue_insert(s-&gt;d1-&gt;buffered_messages, item);</span><br><span class=\"line\">+               item = pqueue_insert(s-&gt;d1-&gt;buffered_messages, item);</span><br><span class=\"line\">+               <span class=\"comment\">/* pqueue_insert fails iff a duplicate item is inserted.</span></span><br><span class=\"line\"><span class=\"comment\">+                * However, |item| cannot be a duplicate. If it were,</span></span><br><span class=\"line\"><span class=\"comment\">+                * |pqueue_find|, above, would have returned it and control</span></span><br><span class=\"line\"><span class=\"comment\">+                * would never have reached this branch. */</span></span><br><span class=\"line\">+               OPENSSL_assert(item != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> DTLS1_HM_FRAGMENT_RETRY;</span><br><span class=\"line\">@@ <span class=\"number\">-751</span>,<span class=\"number\">7</span> +<span class=\"number\">759</span>,<span class=\"number\">7</span> @@ dtls1_process_out_of_seq_message(SSL *s, <span class=\"keyword\">struct</span> hm_header_st* msg_hdr, <span class=\"type\">int</span> *ok)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">-               <span class=\"keyword\">if</span> (frag_len &amp;&amp; frag_len &lt; msg_hdr-&gt;msg_len)</span><br><span class=\"line\">+               <span class=\"keyword\">if</span> (frag_len &lt; msg_hdr-&gt;msg_len)</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> dtls1_reassemble_fragment(s, msg_hdr, ok);</span><br><span class=\"line\"> </span><br><span class=\"line\">                <span class=\"keyword\">if</span> (frag_len &gt; dtls1_max_handshake_message_len(s))</span><br><span class=\"line\">@@ <span class=\"number\">-780</span>,<span class=\"number\">7</span> +<span class=\"number\">788</span>,<span class=\"number\">15</span> @@ dtls1_process_out_of_seq_message(SSL *s, <span class=\"keyword\">struct</span> hm_header_st* msg_hdr, <span class=\"type\">int</span> *ok)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ( item == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">                        <span class=\"keyword\">goto</span> err;</span><br><span class=\"line\"> </span><br><span class=\"line\">-               pqueue_insert(s-&gt;d1-&gt;buffered_messages, item);</span><br><span class=\"line\">+               item = pqueue_insert(s-&gt;d1-&gt;buffered_messages, item);</span><br><span class=\"line\">+               <span class=\"comment\">/* pqueue_insert fails iff a duplicate item is inserted.</span></span><br><span class=\"line\"><span class=\"comment\">+                * However, |item| cannot be a duplicate. If it were,</span></span><br><span class=\"line\"><span class=\"comment\">+                * |pqueue_find|, above, would have returned it. Then, either</span></span><br><span class=\"line\"><span class=\"comment\">+                * |frag_len| != |msg_hdr-&gt;msg_len| in which case |item| is set</span></span><br><span class=\"line\"><span class=\"comment\">+                * to NULL and it will have been processed with</span></span><br><span class=\"line\"><span class=\"comment\">+                * |dtls1_reassemble_fragment|, above, or the record will have</span></span><br><span class=\"line\"><span class=\"comment\">+                * been discarded. */</span></span><br><span class=\"line\">+               OPENSSL_assert(item != <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">        <span class=\"keyword\">return</span> DTLS1_HM_FRAGMENT_RETRY;</span><br></pre></td></tr></table></figure>\n<p>这个相比较第一个就复杂一些，影响版本为小于 1.0.1</p>\n",
            "tags": [
                "二进制学习"
            ]
        }
    ]
}